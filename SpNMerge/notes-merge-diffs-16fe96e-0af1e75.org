* master to last-merged
** .github/workflows/mpi.yml
19c19,22
<         dir: [Algebra,DiracOperator,Geometry,Inverters,Mesons,PureGauge,RIMOM,Sources,StoredConfs,Utils,Disconnected,GaugeFix,Propagator,Random,Scattering,SpinorField,Update,WilsonLoops]
---
>         dir: [Algebra,DiracOperator,Geometry,Inverters,Integrators,Mesons,PureGauge,RIMOM,Sources,StoredConfs,Utils,Disconnected,GaugeFix,Propagator,Random,Scattering,SpinorField,Update,WilsonLoops]
>         exclude:
>           - nc: 3
>             repr: ADJ
** .github/workflows/no-mpi.yml
19c19,22
<         dir: [Algebra,DiracOperator,Geometry,Inverters,Mesons,PureGauge,RIMOM,Sources,StoredConfs,Utils,Disconnected,GaugeFix,Propagator,Random,Scattering,SpinorField,Update,WilsonLoops]
---
>         dir: [Algebra,DiracOperator,Geometry,Inverters,Integrators,Mesons,PureGauge,RIMOM,Sources,StoredConfs,Utils,Disconnected,GaugeFix,Propagator,Random,Scattering,SpinorField,Update,WilsonLoops]
>         exclude:
>           - nc: 3
>             repr: ADJ
** .gitignore
24a25
> Hirep-git.code-workspace
** Disconnected/compute_loops.c
12a13
> #include "data_storage.h"
101c102
<   int nm;
---
> 
129d129
<   nm = 1;
153,154c153,154
<     measure_loops(nm, m, disc_var.nhits, i, disc_var.precision,
<                   disc_var.source_type, disc_var.n_mom, NULL);
---
>     measure_loops(m, disc_var.nhits, i, disc_var.precision,
>                   disc_var.source_type, disc_var.n_mom, DONTSTORE, NULL);
** HMC/hmc.c
14a15
> #include "data_storage.h"
264c265
<                                  mes_var.precision);
---
>                                  mes_var.precision, DONTSTORE, NULL);
318,321c319
<   /* finalize Monte Carlo */
<   end_mc();
< 
<   /* close communications */
---
>   /* inalize Monte Carlo & close communications */
** HMC/hmc_forces.c
240,242c240
<     rlxd_init(rlx_var.rlxd_level,
<               rlx_var.rlxd_seed +
<                   MPI_PID); /* use unique MPI_PID to shift seeds */
---
>     rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
379,381d376
< 
<   /* finalize Monte Carlo */
<   end_mc();
** HMC/hmc_utils.c
351,367d350
< 
< /* clean up memory */
< int end_mc() {
<   free_ghmc();
<   free_BCs();
< 
<   /* free memory */
<   free_gfield(u_gauge);
< #ifdef ALLOCATE_REPR_GAUGE_FIELD
<   free_gfield_f(u_gauge_f);
< #endif
<   if (u_scalar != NULL) {
<     free_scalar_field(u_scalar);
<   }
< 
<   return 0;
< }
** HMC/hmc_utils.h
82d81
< int end_mc();
** Include/dirac.h
12a13
> void Dphi_fused_(spinor_field *out, spinor_field *in);
** Include/disconnected.h
12a13
> #include "data_storage.h"
17,18c18,20
<                                         spinor_field *source, int k, int nm,
<                                         int n_mom, double complex ***out_corr);
---
>                                         spinor_field *source, int src_id,
>                                         int n_mom, storage_switch swc,
>                                         data_storage_array **ret);
20c22
<                                          spinor_field *source, int k, int nm,
---
>                                          spinor_field *source, int src_id,
22c24,25
<                                          double complex ***out_corr);
---
>                                          storage_switch swc,
>                                          data_storage_array **ret);
24,25c27,29
< void measure_loops(int nm, double *m, int nhits, int conf_num, double precision,
<                    int source_type, int n_mom, double complex ***out_corr);
---
> void measure_loops(double *m, int nhits, int conf_num, double precision,
>                    int source_type, int n_mom, storage_switch swc,
>                    data_storage_array **ret);
** Include/geometry.h
36a37,39
>   int *fuse_mask;
>   int fuse_gauge_size;
>   int fuse_inner_counter;
46a50
>   _OMP_PRAGMA(_omp_parallel)                                                   \
50a55
> //#define _SITE_FOR(type, ip, is) _SITE_FOR_RED(type, ip, is, , )
70a76,93
> 
> #define _FUSE_IDX(type, is) (type)->fuse_mask[_fuse_master_for_ip_##is]
> 
> #define _FUSE_FOR_RED(type, ip, is, redop1, redop2)                            \
>   _OMP_PRAGMA(_omp_parallel)                                                   \
>   _OMP_PRAGMA(_omp_for redop1 redop2)                                          \
>   for (int ip = 0; ip < type->fuse_gauge_size; ip++)
> 
> #define _FUSE_MASTER_FOR_RED(type, is, redop1, redop2)                         \
>   _FUSE_FOR_RED((type), _fuse_master_for_ip_##is, is, redop1, redop2)
> 
> #define _FUSE_MASTER_FOR(type, is) _FUSE_MASTER_FOR_RED(type, is, nowait, )
> #define _FUSE_MASTER_FOR_SUM(type, is, ...)                                    \
>   _FUSE_MASTER_FOR_RED(type, is, _omp_sum(__VA_ARGS__), )
> #define _FUSE_MASTER_FOR_MAX(type, is, ...)                                    \
>   _FUSE_MASTER_FOR_RED(type, is, _omp_max(__VA_ARGS__), )
> #define _FUSE_MASTER_FOR_MIN(type, is, ...)                                    \
>   _FUSE_MASTER_FOR_RED(type, is, _omp_min(__VA_ARGS__), )
** Include/global.h
62a63,68
> /*path blocking size*/
> GLB_VAR(int, PB_T, = 2);
> GLB_VAR(int, PB_X, = 2);
> GLB_VAR(int, PB_Y, = 2);
> GLB_VAR(int, PB_Z, = 2);
> 
** Include/glueballs.h
10,11c10,11
< void measure_1pt_glueballs(int nblocking, double *smear_val,
<                            double complex *gb_storage);
---
> void measure_1pt_glueballs(int nblockingstart, int nblockingend,
>                            double *smear_val, double complex *gb_storage);
** Include/memory.h
24c24
< #define ALIGN 5
---
> #define ALIGN 8
** Include/observables.h
141a142
> 
161a163
> 
187c189,190
< void contract_baryons(spinor_field *psi0, int tau);
---
> void contract_baryons(spinor_field *psi0, int tau, storage_switch swc,
>                       data_storage_array **ret);
** Include/propagator.h
83,86c83,86
<     int a, beta;                                                               \
<     for (a = 0; a < NF; ++a)                                                   \
<       for (beta = 0; beta < 4; ++beta) {                                       \
<         _spinor_add_f(p.c[a].c[beta], q.c[a].c[beta], r.c[a].c[beta]);         \
---
>     int _a, _beta;                                                             \
>     for (_a = 0; _a < NF; ++_a)                                                \
>       for (_beta = 0; _beta < 4; ++_beta) {                                    \
>         _spinor_add_f(p.c[_a].c[_beta], q.c[_a].c[_beta], r.c[_a].c[_beta]);   \
92,95c92,95
<     int a, beta;                                                               \
<     for (a = 0; a < NF; ++a)                                                   \
<       for (beta = 0; beta < 4; ++beta) {                                       \
<         _spinor_sub_f(p.c[a].c[beta], q.c[a].c[beta], r.c[a].c[beta]);         \
---
>     int _a, _beta;                                                             \
>     for (_a = 0; _a < NF; ++_a)                                                \
>       for (_beta = 0; _beta < 4; ++_beta) {                                    \
>         _spinor_sub_f(p.c[_a].c[_beta], q.c[_a].c[_beta], r.c[_a].c[_beta]);   \
102,105c102,105
<     int a, beta;                                                               \
<     for (a = 0; a < NF; ++a)                                                   \
<       for (beta = 0; beta < 4; ++beta) {                                       \
<         _spinor_mul_f((S).c[a].c[beta], k, (S).c[a].c[beta]);                  \
---
>     int _a, _beta;                                                             \
>     for (_a = 0; _a < NF; ++_a)                                                \
>       for (_beta = 0; _beta < 4; ++_beta) {                                    \
>         _spinor_mul_f((S).c[_a].c[_beta], k, (S).c[_a].c[_beta]);              \
147,154c147,154
<     int a, b, alpha, beta;                                                     \
<     for (alpha = 0; alpha < NF; ++alpha) {                                     \
<       for (a = 0; a < NF; ++a) {                                               \
<         for (beta = 0; beta < NF; ++beta) {                                    \
<           for (b = 0; b < NF; ++b) {                                           \
<             _complex_mul_assign((s).c[(alpha)].c[(a)],                         \
<                                 (r).c[(a)].c[(alpha)].c[(beta)].c[(b)],        \
<                                 (t).c[(beta)].c[(b)]);                         \
---
>     int _a, _b, _alpha, _beta;                                                 \
>     for (_alpha = 0; _alpha < NF; ++_alpha) {                                  \
>       for (_a = 0; _a < NF; ++_a) {                                            \
>         for (_beta = 0; _beta < NF; ++_beta) {                                 \
>           for (_b = 0; _b < NF; ++_b) {                                        \
>             _complex_mul_assign((s).c[(_alpha)].c[(_a)],                       \
>                                 (r).c[(_a)].c[(_alpha)].c[(_beta)].c[(_b)],    \
>                                 (t).c[(_beta)].c[(_b)]);                       \
165,172c165,172
<     int a, b, alpha, beta;                                                     \
<     for (beta = 0; beta < NF; ++beta) {                                        \
<       for (b = 0; b < NF; ++b) {                                               \
<         for (alpha = 0; alpha < NF; ++alpha) {                                 \
<           for (a = 0; a < NF; ++a) {                                           \
<             _complex_mul_star_assign((s).c[(beta)].c[(b)],                     \
<                                      (t).c[(alpha)].c[(a)],                    \
<                                      (r).c[(a)].c[(alpha)].c[(beta)].c[(b)]);  \
---
>     int _a, _b, _alpha, _beta;                                                 \
>     for (_beta = 0; _beta < NF; ++_beta) {                                     \
>       for (_b = 0; _b < NF; ++_b) {                                            \
>         for (_alpha = 0; _alpha < NF; ++_alpha) {                              \
>           for (_a = 0; _a < NF; ++_a) {                                        \
>             _complex_mul_star_assign(                                          \
>                 (s).c[(_beta)].c[(_b)], (t).c[(_alpha)].c[(_a)],               \
>                 (r).c[(_a)].c[(_alpha)].c[(_beta)].c[(_b)]);                   \
182,192c182,192
<     int a, b, c, alpha, beta, gamma;                                           \
<     for (a = 0; a < NF; ++a) {                                                 \
<       for (b = 0; b < NF; ++b) {                                               \
<         for (alpha = 0; alpha < 4; ++alpha) {                                  \
<           for (beta = 0; beta < 4; ++beta) {                                   \
<             _complex_0(Q.c[a].c[alpha].c[beta].c[b]);                          \
<             for (c = 0; c < NF; c++) {                                         \
<               for (gamma = 0; gamma < 4; gamma++) {                            \
<                 _complex_mul_assign(Q.c[a].c[alpha].c[beta].c[b],              \
<                                     S.c[a].c[alpha].c[gamma].c[c],             \
<                                     R.c[c].c[gamma].c[beta].c[b]);             \
---
>     int _a, _b, _c, _alpha, _beta, _gamma;                                     \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       for (_b = 0; _b < NF; ++_b) {                                            \
>         for (_alpha = 0; _alpha < 4; ++_alpha) {                               \
>           for (_beta = 0; _beta < 4; ++_beta) {                                \
>             _complex_0(Q.c[_a].c[_alpha].c[_beta].c[_b]);                      \
>             for (_c = 0; _c < NF; _c++) {                                      \
>               for (_gamma = 0; _gamma < 4; _gamma++) {                         \
>                 _complex_mul_assign(Q.c[_a].c[_alpha].c[_beta].c[_b],          \
>                                     S.c[_a].c[_alpha].c[_gamma].c[_c],         \
>                                     R.c[_c].c[_gamma].c[_beta].c[_b]);         \
204c204
<     int a, b, alpha, beta;                                                     \
---
>     int _a, _b, _alpha, _beta;                                                 \
206,211c206,211
<     for (a = 0; a < NF; ++a) {                                                 \
<       for (alpha = 0; alpha < 4; ++alpha) {                                    \
<         for (b = 0; b < NF; ++b) {                                             \
<           for (beta = 0; beta < 4; ++beta) {                                   \
<             _complex_mul_assign(tr, S.c[a].c[alpha].c[beta].c[b],              \
<                                 R.c[b].c[beta].c[alpha].c[a]);                 \
---
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       for (_alpha = 0; _alpha < 4; ++_alpha) {                                 \
>         for (_b = 0; _b < NF; ++_b) {                                          \
>           for (_beta = 0; _beta < 4; ++_beta) {                                \
>             _complex_mul_assign(tr, S.c[_a].c[_alpha].c[_beta].c[_b],          \
>                                 R.c[_b].c[_beta].c[_alpha].c[_a]);             \
221c221
<     int a, b, alpha, beta;                                                     \
---
>     int _a, _b, _alpha, _beta;                                                 \
223,228c223,228
<     for (a = 0; a < NF; ++a) {                                                 \
<       for (alpha = 0; alpha < 4; ++alpha) {                                    \
<         for (b = 0; b < NF; ++b) {                                             \
<           for (beta = 0; beta < 4; ++beta) {                                   \
<             _complex_prod_assign(tr, S.c[b].c[beta].c[alpha].c[a],             \
<                                  R.c[b].c[beta].c[alpha].c[a]);                \
---
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       for (_alpha = 0; _alpha < 4; ++_alpha) {                                 \
>         for (_b = 0; _b < NF; ++_b) {                                          \
>           for (_beta = 0; _beta < 4; ++_beta) {                                \
>             _complex_prod_assign(tr, S.c[_b].c[_beta].c[_alpha].c[_a],         \
>                                  R.c[_b].c[_beta].c[_alpha].c[_a]);            \
239,244c239,244
<     int a, b, alpha, beta;                                                     \
<     for (beta = 0; beta < 4; ++beta)                                           \
<       for (alpha = 0; alpha < 4; ++alpha) {                                    \
<         for (b = 0; b < NF; ++b) {                                             \
<           for (a = 0; a < NF; ++a) {                                           \
<             v1.c[a] = (s).c[a].c[alpha].c[beta].c[b];                          \
---
>     int _a, _b, _alpha, _beta;                                                 \
>     for (_beta = 0; _beta < 4; ++_beta)                                        \
>       for (_alpha = 0; _alpha < 4; ++_alpha) {                                 \
>         for (_b = 0; _b < NF; ++_b) {                                          \
>           for (_a = 0; _a < NF; ++_a) {                                        \
>             v1.c[_a] = (s).c[_a].c[_alpha].c[_beta].c[_b];                     \
247,248c247,248
<           for (a = 0; a < NF; ++a) {                                           \
<             (us).c[a].c[alpha].c[beta].c[b] = v2.c[a];                         \
---
>           for (_a = 0; _a < NF; ++_a) {                                        \
>             (us).c[_a].c[_alpha].c[_beta].c[_b] = v2.c[_a];                    \
258,263c258,263
<     int a, b, alpha, beta;                                                     \
<     for (beta = 0; beta < 4; ++beta)                                           \
<       for (alpha = 0; alpha < 4; ++alpha) {                                    \
<         for (b = 0; b < NF; ++b) {                                             \
<           for (a = 0; a < NF; ++a) {                                           \
<             v1.c[a] = (s).c[a].c[alpha].c[beta].c[b];                          \
---
>     int _a, _b, _alpha, _beta;                                                 \
>     for (_beta = 0; _beta < 4; ++_beta)                                        \
>       for (_alpha = 0; _alpha < 4; ++_alpha) {                                 \
>         for (_b = 0; _b < NF; ++_b) {                                          \
>           for (_a = 0; _a < NF; ++_a) {                                        \
>             v1.c[_a] = (s).c[_a].c[_alpha].c[_beta].c[_b];                     \
266,267c266,267
<           for (a = 0; a < NF; ++a) {                                           \
<             (us).c[a].c[alpha].c[beta].c[b] = v2.c[a];                         \
---
>           for (_a = 0; _a < NF; ++_a) {                                        \
>             (us).c[_a].c[_alpha].c[_beta].c[_b] = v2.c[_a];                    \
286,288c286,288
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g0_spinmatrix((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g0_spinmatrix((p).c[_a], (q).c[_a]);                                    \
294,296c294,296
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g1_spinmatrix((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g1_spinmatrix((p).c[_a], (q).c[_a]);                                    \
302,304c302,304
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g2_spinmatrix((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g2_spinmatrix((p).c[_a], (q).c[_a]);                                    \
310,312c310,312
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g3_spinmatrix((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g3_spinmatrix((p).c[_a], (q).c[_a]);                                    \
318,320c318,320
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5_spinmatrix((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5_spinmatrix((p).c[_a], (q).c[_a]);                                    \
326,328c326,328
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5g0_spinmatrix((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5g0_spinmatrix((p).c[_a], (q).c[_a]);                                  \
334,336c334,336
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5g3_spinmatrix((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5g3_spinmatrix((p).c[_a], (q).c[_a]);                                  \
342,344c342,344
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5g1_spinmatrix((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5g1_spinmatrix((p).c[_a], (q).c[_a]);                                  \
350,352c350,352
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5g2_spinmatrix(p.c[a], q.c[a]);                                        \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5g2_spinmatrix(p.c[_a], q.c[_a]);                                      \
359,361c359,361
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g0((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g0((p).c[_a], (q).c[_a]);                                    \
367,369c367,369
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g2((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g2((p).c[_a], (q).c[_a]);                                    \
375,377c375,377
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g5((p).c[a], (q).c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g5((p).c[_a], (q).c[_a]);                                    \
383,385c383,385
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g5g0((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g5g0((p).c[_a], (q).c[_a]);                                  \
391,393c391,393
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5g0g1_spinmatrix(p.c[a], q.c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5g0g1_spinmatrix(p.c[_a], q.c[_a]);                                    \
399,401c399,401
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5g0g2_spinmatrix((p).c[a], (q).c[a]);                                  \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5g0g2_spinmatrix((p).c[_a], (q).c[_a]);                                \
407,409c407,409
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g5g0g2((p).c[a], (q).c[a]);                                  \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g5g0g2((p).c[_a], (q).c[_a]);                                \
415,417c415,417
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g5g0g3_spinmatrix(p.c[a], q.c[a]);                                      \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g5g0g3_spinmatrix(p.c[_a], q.c[_a]);                                    \
423,425c423,425
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g5g3((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g5g3((p).c[_a], (q).c[_a]);                                  \
431,433c431,433
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g5g1((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g5g1((p).c[_a], (q).c[_a]);                                  \
439,441c439,441
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g0g1_spinmatrix(p.c[a], q.c[a]);                                        \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g0g1_spinmatrix(p.c[_a], q.c[_a]);                                      \
447,449c447,449
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g0g2_spinmatrix((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g0g2_spinmatrix((p).c[_a], (q).c[_a]);                                  \
455,457c455,457
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _spinmatrix_g0g2((p).c[a], (q).c[a]);                                    \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _spinmatrix_g0g2((p).c[_a], (q).c[_a]);                                  \
463,465c463,465
<     int a;                                                                     \
<     for (a = 0; a < NF; ++a) {                                                 \
<       _g0g3_spinmatrix(p.c[a], q.c[a]);                                        \
---
>     int _a;                                                                    \
>     for (_a = 0; _a < NF; ++_a) {                                              \
>       _g0g3_spinmatrix(p.c[_a], q.c[_a]);                                      \
** Include/ranlux.h
** Include/spectrum.h
14a15
> #include "data_storage.h"
20c21,22
<                               double precision);
---
>                               double precision, storage_switch swc,
>                               data_storage_array **ret);
22c24,25
<                                      double precision);
---
>                                      double precision, storage_switch swc,
>                                      data_storage_array **ret);
24c27,28
<                                     double precision);
---
>                                     double precision, storage_switch swc,
>                                     data_storage_array **ret);
26,27c30,34
<                                     double precision, int dil);
< void measure_spectrum_gfwall(int nm, double *m, int conf_num, double precision);
---
>                                     double precision, int dil,
>                                     storage_switch swc,
>                                     data_storage_array **ret);
> void measure_spectrum_gfwall(int nm, double *m, int conf_num, double precision,
>                              storage_switch swc, data_storage_array **ret);
29c36,37
<                          double precision);
---
>                          double precision, storage_switch swc,
>                          data_storage_array **ret);
31c39,40
<                                   double precision);
---
>                                   double precision, storage_switch swc,
>                                   data_storage_array **ret);
33c42,43
<                              int conf_num, double precision);
---
>                              int conf_num, double precision, storage_switch swc,
>                              data_storage_array **ret);
35c45,47
<                                       int conf_num, double precision);
---
>                                       int conf_num, double precision,
>                                       storage_switch swc,
>                                       data_storage_array **ret);
37c49,50
<                                  int conf_num, double precision);
---
>                                  int conf_num, double precision,
>                                  storage_switch swc, data_storage_array **ret);
39c52,53
<                                      double precision);
---
>                                      double precision, storage_switch swc,
>                                      data_storage_array **ret);
41c55,56
<                            int conf_num, double precision);
---
>                            int conf_num, double precision, storage_switch swc,
>                            data_storage_array **ret);
43c58,59
<                               int n_mom, int conf_num, double precision);
---
>                               int n_mom, int conf_num, double precision,
>                               storage_switch swc, data_storage_array **ret);
46c62,63
<                                         double precision);
---
>                                         double precision, storage_switch swc,
>                                         data_storage_array **ret);
50,51c67,70
<                                         double Q, int n);
< void measure_baryons(double *m, int conf_num, double precision);
---
>                                         double Q, int n, storage_switch swc,
>                                         data_storage_array **ret);
> void measure_baryons(double *m, int conf_num, double precision,
>                      storage_switch swc, data_storage_array **ret);
55c74,75
<                                  double precision);
---
>                                  double precision, storage_switch swc,
>                                  data_storage_array **ret);
58c78,80
<                                         int conf_num, double precision);
---
>                                         int conf_num, double precision,
>                                         storage_switch swc,
>                                         data_storage_array **ret);
60c82,83
<                             double precision);
---
>                             double precision, storage_switch swc,
>                             data_storage_array **ret);
62c85,86
<                                      double precision);
---
>                                      double precision, storage_switch swc,
>                                      data_storage_array **ret);
** Include/spin_matrix.h
** Include/spinor_field.h
64,65c64,65
<   for (int i = 0; i < n; i++)                                                  \
<     error((s)->type != ((s) + i)->type, 1, __FILE__ ": ",                      \
---
>   for (int _i = 0; _i < n; _i++)                                               \
>     error((s)->type != ((s) + _i)->type, 1, __FILE__ ": ",                     \
** Include/update.h
26c26,27
<                                      int *ml_up, int *ml_skip, int nblocking,
---
>                                      int *ml_up, int *ml_skip,
>                                      int nblockingstart, int nblockingsend,
** Include/utils.h
25,26c25,26
< void WF_Exp(suNg *u, suNg *X);
< void WF_Exp_Taylor(suNg *u, suNg *X);
---
> void suNg_Exp(suNg *u, suNg *X);
> void suNg_Exp_Taylor(suNg *u, suNg *X);
** LibHR/Geometry/communications.c
555c555
<           lprintf("MPI", 0, "Req [%d] Source [%d] Tag [%] ERROR: %s\n", k,
---
>           lprintf("MPI", 0, "Req [%d] Source [%d] Tag [%d] ERROR: %s\n", k,
** LibHR/Geometry/geometry_init.c
391a392,393
>   lprintf("GEOMETRY_INIT", 0, "Size of the bulk subblocking (%d,%d,%d,%d)\n",
>           PB_T, PB_X, PB_Y, PB_Z);
** LibHR/Geometry/geometry_mpi_eo.c
347a348,375
> void eval_fusemask(geometry_descriptor *lglat) {
>   int counter = 0;
>   for (int ip = 0; ip < lglat->local_master_pieces; ip++)
>     counter += lglat->master_end[ip] - lglat->master_start[ip] + 1;
> 
>   lglat->fuse_gauge_size = counter;
> 
>   lglat->fuse_mask =
>       malloc(counter * sizeof(int)); // allocating memory for local volume
> 
>   lglat->fuse_inner_counter = counter;
> 
>   counter = 0;
>   /* loop through PIECEs */
>   for (int ip = 0; ip < lglat->local_master_pieces; ip++) {
>     /* loop through SITEs in PIECEs */
>     for (int is = lglat->master_start[ip]; is <= lglat->master_end[ip]; is++) {
>       lglat->fuse_mask[counter] = is;
>       counter++;
>     }
> 
>     if (ip == lglat->inner_master_pieces) {
>       lglat->fuse_inner_counter =
>           (lglat)->master_start[ip] - (lglat)->master_shift;
>     }
>   }
> }
> 
409c437
< static void walk_on_lattice(int id_mask, int eotype, int level, int id_zone,
---
> void walk_on_lattice(int id_mask, int eotype, int level, int id_zone,
410a439,441
>   int evblock[4] = {PB_T, PB_X, PB_Y, PB_Z};
>   if (level != 4)
>     evblock[0] = evblock[1] = evblock[2] = evblock[3] = 1;
411a443
>   int bx0, bx1, bx2, bx3;
424a457,459
>   lprintf("GEOMETRY", REPORTLVL, "blocking of the pathsize (%d,%d,%d,%d) \n",
>           evblock[0], evblock[1], evblock[2], evblock[3]);
> 
427,441c462,496
<     for (x3 = bl_start[3];
<          block_cond(bl_start[3], bl_start[3] + bl_width[3], x3); x3 += incr[3])
<       for (x2 = bl_start[2];
<            block_cond(bl_start[2], bl_start[2] + bl_width[2], x2);
<            x2 += incr[2])
<         for (x1 = bl_start[1];
<              block_cond(bl_start[1], bl_start[1] + bl_width[1], x1);
<              x1 += incr[1])
<           for (x0 = bl_start[0];
<                block_cond(bl_start[0], bl_start[0] + bl_width[0], x0);
<                x0 += incr[0]) {
<             x[inv_mask[id_mask][0]] = x0;
<             x[inv_mask[id_mask][1]] = x1;
<             x[inv_mask[id_mask][2]] = x2;
<             x[inv_mask[id_mask][3]] = x3;
---
>     for (bx3 = bl_start[3];
>          block_cond(bl_start[3], bl_start[3] + bl_width[3], bx3);
>          bx3 += incr[3] * evblock[inv_mask[id_mask][3]])
>       for (bx2 = bl_start[2];
>            block_cond(bl_start[2], bl_start[2] + bl_width[2], bx2);
>            bx2 += incr[2] * evblock[inv_mask[id_mask][2]])
>         for (bx1 = bl_start[1];
>              block_cond(bl_start[1], bl_start[1] + bl_width[1], bx1);
>              bx1 += incr[1] * evblock[inv_mask[id_mask][1]])
>           for (bx0 = bl_start[0];
>                block_cond(bl_start[0], bl_start[0] + bl_width[0], bx0);
>                bx0 += incr[0] * evblock[inv_mask[id_mask][0]]) {
>             for (x3 = 0; (x3 < evblock[inv_mask[id_mask][3]]) &&
>                          block_cond(bl_start[3], bl_start[3] + bl_width[3],
>                                     bx3 + incr[3] * x3);
>                  x3++)
>               for (x2 = 0; (x2 < evblock[inv_mask[id_mask][2]]) &&
>                            block_cond(bl_start[2], bl_start[2] + bl_width[2],
>                                       bx2 + incr[2] * x2);
>                    x2++)
>                 for (x1 = 0; (x1 < evblock[inv_mask[id_mask][1]]) &&
>                              block_cond(bl_start[1], bl_start[1] + bl_width[1],
>                                         bx1 + incr[1] * x1);
>                      x1++)
>                   for (x0 = 0;
>                        (x0 < evblock[inv_mask[id_mask][0]]) &&
>                        block_cond(bl_start[0], bl_start[0] + bl_width[0],
>                                   bx0 + incr[0] * x0);
>                        x0++) {
> 
>                     x[inv_mask[id_mask][0]] = bx0 + incr[0] * x0;
>                     x[inv_mask[id_mask][1]] = bx1 + incr[1] * x1;
>                     x[inv_mask[id_mask][2]] = bx2 + incr[2] * x2;
>                     x[inv_mask[id_mask][3]] = bx3 + incr[3] * x3;
> 
443,444c498,499
<                 eotype == (x0 + x1 + x2 + x3 + T_BORDER + X_BORDER + Y_BORDER +
<                            Z_BORDER + PSIGN) %
---
>                         eotype == (x[0] + x[1] + x[2] + x[3] + T_BORDER +
>                                    X_BORDER + Y_BORDER + Z_BORDER + PSIGN) %
447,448c502,503
<                       "walk_on_lattice T[%d] X[%d] Y[%d] Z[%d] \n", x[0], x[1],
<                       x[2], x[3]);
---
>                               "walk_on_lattice T[%d] X[%d] Y[%d] Z[%d] \n",
>                               x[0], x[1], x[2], x[3]);
458c513,514
< 
---
>             lprintf("GEOMETRY", REPORTLVL, "subblock\n");
>           }
1675a1732,1733
> 
>     eval_fusemask(&glattice);
1694a1753,1754
> 
>     eval_fusemask(&glat_even);
1713a1774,1775
> 
>     eval_fusemask(&glat_odd);
** LibHR/Geometry/process_init.c
128c128,129
<   int required = MPI_THREAD_SINGLE;
---
>   int required = MPI_THREAD_FUNNELED;
> 
137a139,142
>   error(provided < MPI_THREAD_FUNNELED, 1, "setup_process " __FILE__,
>         "MPI inizialization failed, The threading support level is lesser than "
>         "that demanded.\n");
> 
222,224c227
<     rlxd_init(rlx_var.rlxd_level,
<               rlx_var.rlxd_seed +
<                   MPI_PID); /* use unique MPI_PID to shift seeds */
---
>     rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** LibHR/Geometry/test_geometry_mpi.c
1157,1178d1156
< /*
< typedef struct _geometry_descriptor {
<   int inner_master_pieces;
<   int local_master_pieces;
<   int total_spinor_master_pieces;
<   int total_gauge_master_pieces;
<   int *master_start, *master_end;
<   int master_shift;
<   int ncopies_spinor;
<   int ncopies_gauge;
<   int *copy_from, *copy_to, *copy_len;
<   int copy_odd_shift;
<   int nbuffers_spinor;
<   int nbuffers_gauge;
<   int *rbuf_len, *sbuf_len;
<   int *rbuf_from_proc, *rbuf_start;
<   int *sbuf_to_proc, *sbuf_start;
<   int gsize_spinor;
<   int gsize_gauge;
< } geometry_descriptor;
< */
< 
** LibHR/IO/archive.c
134c134
<                 double *p = _FIELD_AT(ff_pi, ix);
---
>                 double *pl = _FIELD_AT(ff_pi, ix);
136c136
<                 *(s_buff++) = *p;
---
>                 *(s_buff++) = *pl;
385c385
<                 double *p = _FIELD_AT(ff_pi, ix);
---
>                 double *pl = _FIELD_AT(ff_pi, ix);
387c387
<                 *(p) = *(s_buff++);
---
>                 *(pl) = *(s_buff++);
410c410
<       lprintf("ERROR", 0,
---
>       lprintf("WARNING", 0,
414c414
<       error(1, 1, "read_gauge_field " __FILE__, "Plaquette value mismatch");
---
>       // error(1, 1, "read_gauge_field " __FILE__, "Plaquette value mismatch");
580c580
<       lprintf("ERROR", 0,
---
>       lprintf("WARNING", 0,
583c583
<       error(1, 1, "read_ranlxd_state " __FILE__, "ranlxd size mismatch");
---
>       // error(1, 1, "read_ranlxd_state " __FILE__, "ranlxd size mismatch");
** LibHR/IO/archive_su2quat.c
166c166
<                 double *p = _FIELD_AT(ff_pi, ix);
---
>                 double *pl = _FIELD_AT(ff_pi, ix);
168c168
<                 *(s_buff++) = *p;
---
>                 *(s_buff++) = *pl;
414c414
<                 double *p = _FIELD_AT(ff_pi, ix);
---
>                 double *pl = _FIELD_AT(ff_pi, ix);
416c416
<                 *(p) = *(s_buff++);
---
>                 *(pl) = *(s_buff++);
** LibHR/IO/logger.c
472c472
<   static char buf[1024];
---
>   static char buf[4096];
** LibHR/IO/read_action.c
600a601
>   int result;
619,622c620,625
<   content = malloc(fsz);
<   lines = malloc(fsz);
<   type = malloc(fsz);
<   fread(content, fsz, 1, fp);
---
>   content = malloc(sizeof(char) * (fsz + 256));
>   lines = malloc(sizeof(char) * (fsz));
>   type = malloc(sizeof(char) * (fsz));
>   result = fread(content, 1, fsz, fp);
>   check(result != fsz, "Reading error\n");
> 
** LibHR/Inverters/cg_mshift_flt.c
** LibHR/Memory/amalloc.c
112,113c112,113
<   true_addr = malloc(size + shift);
<   new = malloc(sizeof(*first));
---
>   true_addr = (char *)malloc(size + shift);
>   new = (struct addr_t *)malloc(sizeof(*first));
** LibHR/Memory/field_alloc.c
** LibHR/Observables/baryon_measurements.c
6a7
> #include "data_storage.h"
32a34
> 
34c36,37
< void measure_baryons(double *m, int conf_num, double precision) {
---
> void measure_baryons(double *m, int conf_num, double precision,
>                      storage_switch swc, data_storage_array **ret) {
56c59
<   contract_baryons(prop, tau);
---
>   contract_baryons(prop, tau, swc, ret);
** LibHR/Observables/calc_prop.c
327c327
<   static int init = 0;
---
>   static int local_init = 0;
331c331
<   double tmp;
---
>   double loc_tmp;
336c336
<   mpar.shift = &tmp;
---
>   mpar.shift = &loc_tmp;
340c340
<   if (init == 0) {
---
>   if (local_init == 0) {
344c344
<     init = 1;
---
>     local_init = 1;
** LibHR/Observables/g5QMR_trunc.c
224d223
< 
** LibHR/Observables/glueballs.c
10,11c10,11
< void measure_1pt_glueballs(int nblocking, double *smear_val,
<                            double complex *gb_storage) {
---
> void measure_1pt_glueballs(int nblockingstart, int nblockingend,
>                            double *smear_val, double complex *gb_storage) {
18c18
<   for (i = 0; i < nblocking; i++) {
---
>   for (i = 0; i < nblockingstart; i++) {
26a27
>   }
27a29
>   for (i = 0; i < nblockingend - nblockingstart; i++) {
29d30
< 
32c33
<       point_gb += total_n_glue_op * nblocking;
---
>       point_gb += total_n_glue_op * (nblockingend - nblockingstart + 1);
33a35,49
> 
>     wrk1 = spatial_APE_smear_wrkspace(smear_val, wrk2);
> 
>     release_wrk_space(wrk2);
> 
>     wrk2 = single_level_spatial_blocking_wrkspace(wrk1);
> 
>     release_wrk_space(wrk1);
>   }
> 
>   point_gb = gb_storage + (nblockingend - nblockingstart) * total_n_glue_op;
> 
>   for (nt = 0; nt < n_active_slices; nt++) {
>     eval_all_glueball_ops(active_slices_list[nt], point_gb);
>     point_gb += total_n_glue_op * (nblockingend - nblockingstart + 1);
** LibHR/Observables/loop_tools.c
9a10
> #include "data_storage.h"
50c51
<                                          spinor_field *source, int k, int nm,
---
>                                          spinor_field *source, int src_id,
52c53,54
<                                          double complex ***out_corr) {
---
>                                          storage_switch swc,
>                                          data_storage_array **ret) {
58c60
<   int i, ix, t, x, y, z, tc, beta;
---
>   int ix, t, x, y, z, tc, beta;
68,71d69
<   if (nm != 1)
<     error(nm != 1, 1, "[measure_biliniear_loops_4spinorfield]",
<           "Multimass not implemented !");
< 
86,87d83
<   /* loop on nm if the MMS is used */
<   for (i = 0; i < nm; i++) {
89c85
<       tc = (zerocoord[0] + t + GLB_T) % GLB_T + i * GLB_T;
---
>     tc = (zerocoord[0] + t + GLB_T) % GLB_T;
97,100c93,94
<               _spinmatrix_assign_row(
<                   sma, *_FIELD_AT(&source[beta * nm + i], ix), beta);
<               _spinmatrix_assign_row(smb, *_FIELD_AT(&prop[beta * nm + i], ix),
<                                      beta);
---
>             _spinmatrix_assign_row(sma, *_FIELD_AT(&source[beta], ix), beta);
>             _spinmatrix_assign_row(smb, *_FIELD_AT(&prop[beta], ix), beta);
158d151
<   }   /* end loop i (nm) */
176,178c169,171
<     global_sum(corr_re[iGamma], GLB_T * nm);
<     global_sum(corr_im[iGamma], GLB_T * nm);
<     global_sum((double *)(corr[iGamma]), 2 * GLB_T * nm);
---
>     global_sum(corr_re[iGamma], GLB_T);
>     global_sum(corr_im[iGamma], GLB_T);
>     global_sum((double *)(corr[iGamma]), 2 * GLB_T);
181c174
<   if (k == 0 && tau == -1 && col == -1 && eo == -1)
---
>   if (src_id == 0 && tau == -1 && col == -1 && eo == -1)
184c177
<   if (k == 0 && tau == 0 && col == -1 && eo == -1)
---
>   if (src_id == 0 && tau == 0 && col == -1 && eo == -1)
187c180
<   if (k == 0 && tau == 0 && col == 0 && eo == -1)
---
>   if (src_id == 0 && tau == 0 && col == 0 && eo == -1)
191c184
<   if (k == 0 && tau == 0 && col == 0 && eo == 0)
---
>   if (src_id == 0 && tau == 0 && col == 0 && eo == 0)
196c189
<   if (k == 0 && tau == -1 && col == 0 && eo == -1)
---
>   if (src_id == 0 && tau == -1 && col == 0 && eo == -1)
199c192
<   if (k == 0 && tau == -1 && col == 0 && eo == 0)
---
>   if (src_id == 0 && tau == -1 && col == 0 && eo == 0)
207c200
<         lprintf("CORR", 0, "%i %i %i %3.10e %3.10e \n", t, iGamma, k,
---
>         lprintf("CORR", 0, "%i %i %i %3.10e %3.10e \n", t, iGamma, src_id,
209,210c202,207
<         if (out_corr != NULL)
<           out_corr[0][iGamma][t] += corr_re[iGamma][t];
---
>         if (swc == STORE) {
>           int idx[4] = {src_id, iGamma, t, 0};
>           *data_storage_element(*ret, 0, idx) = corr_re[iGamma][t];
>           idx[3] = 1;
>           *data_storage_element(*ret, 0, idx) = corr_im[iGamma][t];
>         }
216,219c213,220
<         lprintf("CORR", 0, "%i %i %i %i %3.10e %3.10e \n", t, iGamma, k, col,
<                 corr_re[iGamma][t], corr_im[iGamma][t]);
<         if (out_corr != NULL)
<           out_corr[0][iGamma][t] += corr[iGamma][t];
---
>         lprintf("CORR", 0, "%i %i %i %i %3.10e %3.10e \n", t, iGamma, src_id,
>                 col, corr_re[iGamma][t], corr_im[iGamma][t]);
>         if (swc == STORE) {
>           int idx[5] = {src_id, col, iGamma, t, 0};
>           *data_storage_element(*ret, 0, idx) = corr_re[iGamma][t];
>           idx[4] = 1;
>           *data_storage_element(*ret, 0, idx) = corr_im[iGamma][t];
>         }
224,227c225,232
<         lprintf("CORR", 0, "%i %i %i %i %3.10e %3.10e \n", t, iGamma, k, eo,
<                 corr_re[iGamma][t], corr_im[iGamma][t]);
<         if (out_corr != NULL)
<           out_corr[0][iGamma][t] += corr[iGamma][t];
---
>         lprintf("CORR", 0, "%i %i %i %i %3.10e %3.10e \n", t, iGamma, src_id,
>                 eo, corr_re[iGamma][t], corr_im[iGamma][t]);
>         if (swc == STORE) {
>           int idx[5] = {src_id, eo, iGamma, t, 0};
>           *data_storage_element(*ret, 0, idx) = corr_re[iGamma][t];
>           idx[4] = 1;
>           *data_storage_element(*ret, 0, idx) = corr_im[iGamma][t];
>         }
232,235c237,244
<         lprintf("CORR", 0, "%i %i %i %i %i %3.10e %3.10e \n", t, iGamma, k, col,
<                 eo, corr_re[iGamma][t], corr_im[iGamma][t]);
<         if (out_corr != NULL)
<           out_corr[0][iGamma][t] += corr[iGamma][t];
---
>         lprintf("CORR", 0, "%i %i %i %i %i %3.10e %3.10e \n", t, iGamma, src_id,
>                 col, eo, corr_re[iGamma][t], corr_im[iGamma][t]);
>         if (swc == STORE) {
>           int idx[6] = {src_id, eo, col, iGamma, t, 0};
>           *data_storage_element(*ret, 0, idx) = corr_re[iGamma][t];
>           idx[5] = 1;
>           *data_storage_element(*ret, 0, idx) = corr_im[iGamma][t];
>         }
244c253
<             k, tau, etime.tv_sec, etime.tv_usec);
---
>             src_id, tau, etime.tv_sec, etime.tv_usec);
249c258
<             k, etime.tv_sec, etime.tv_usec);
---
>             src_id, etime.tv_sec, etime.tv_usec);
252,254c261,263
< void measure_loops(int nm, double *m, int nhits, int conf_num, double precision,
<                    int source_type, int n_mom, double complex ***out_corr) {
< 
---
> void measure_loops(double *m, int nhits, int conf_num, double precision,
>                    int source_type, int n_mom, storage_switch swc,
>                    data_storage_array **ret) {
275,279c284,285
<   init_propagator_eo(nm, m, precision);
<   if (nm != 1) {
<     lprintf("ERR", 0, "nm != 1  not tested !\n");
<     exit(1);
<   }
---
>   init_propagator_eo(1, m, precision);
> 
282c288,289
<   suNg_field *u_gauge_old;
---
>   suNg_field *u_gauge_old = NULL;
> 
285,288c292,294
<     prop = alloc_spinor_field_f(nm, &glattice);
<   }
<   if (source_type == 1 || source_type == 2 || source_type == 3 ||
<       source_type == 4 || source_type == 5) {
---
>     prop = alloc_spinor_field_f(1, &glattice);
>     spinor_field_zero_f(prop);
>   } else {
290c296,329
<     prop = alloc_spinor_field_f(4 * nm, &glattice);
---
>     prop = alloc_spinor_field_f(4, &glattice);
>     for (int i = 0; i < 4; i++)
>       spinor_field_zero_f(prop + i);
>   }
> 
>   if (swc == STORE && *ret == NULL) {
>     if (source_type == 0) {
>       int idx[5] = {nhits, pow(n_mom, 3), 16, GLB_T, 2};
>       *ret = allocate_data_storage_array(1);
>       allocate_data_storage_element(
>           *ret, 0, 5, idx); // ( 1 ) * (nhits*nmom^3*ngamma*GLB_T * 2 reals )
>     } else if (source_type == 2) {
>       int idx[4] = {nhits, 16, GLB_T, 2};
>       *ret = allocate_data_storage_array(1);
>       allocate_data_storage_element(
>           *ret, 0, 4, idx); // ( 1 ) * (nhits*ngamma*GLB_T * 2 reals )
>     } else if (source_type == 1 || source_type == 3) {
>       int idx[5] = {nhits, NF, 16, GLB_T, 2};
>       *ret = allocate_data_storage_array(1);
>       allocate_data_storage_element(
>           *ret, 0, 5, idx); // ( 1 ) * (nhits*NF*ngamma*GLB_T * 2 reals )
>     } else if (source_type == 4) {
>       int idx[6] = {nhits, 2, NF, 16, GLB_T, 2};
>       *ret = allocate_data_storage_array(1);
>       allocate_data_storage_element(
>           *ret, 0, 6, idx); // ( 1 ) * (nhits*2(eo)*NF*ngamma*GLB_T * 2 reals )
>     } else if (source_type == 5) {
>       int idx[6] = {nhits, 2, NF, 16, GLB_T, 2};
>       *ret = allocate_data_storage_array(1);
>       allocate_data_storage_element(
>           *ret, 0, 6, idx); // ( 1 ) * (nhits*2(eo)*NF*ngamma*GLB_T * 2 reals )
>     } else
>       error(1, 1, "measure_loops [loop_tools.c]",
>             "Source_type not implemented");
292a332
> 
294a335
>     spinor_field_zero_f(prop);
314,316d354
<       create_z2_volume_source(
<           prop); // the prop is used to build the trial solution by the solver
<                  // and sometimes give rise to an error.
320c358
<       measure_bilinear_loops_spinorfield(prop, source, k, nm, n_mom, out_corr);
---
>       measure_bilinear_loops_spinorfield(prop, source, k, n_mom, swc, ret);
326,328c364,365
<       error(
<           1, 1, "measure_loops [loop_tools.c]",
<           "Source_type ==1 (gauge fixed wall sources) is broken and untested.");
---
>       // error(1, 1, "measure_loops [loop_tools.c]", "Source_type ==1 (gauge
>       // fixed wall sources) is broken and untested.");
330,331c367,368
<       for (tau = 0; tau < GLB_T; ++tau) {
<         for (l = 0; l < NF; ++l) {
---
>       for (tau = 0; tau < GLB_T; tau++)
>         for (l = 0; l < NF; l++) {
335,336c372,374
<           measure_mesons(discon_correlators, prop, source, nm, 0);
<         }
---
>           // measure_mesons(discon_correlators, prop, source, 1, 0);
>           measure_bilinear_loops_4spinorfield(prop, source, k, tau, l, -1, swc,
>                                               ret);
337a376
> 
339,341c378,379
<       // of the disconnected right
<       print_mesons(discon_correlators, 1.0, conf_num, nm, m, GLB_T, 1,
<                    "DISCON_GFWALL");
---
>       // of the disconnected right print_mesons(discon_correlators, 1.0,
>       // conf_num, 1, m, GLB_T, 1, "DISCON_GFWALL");
346d383
< 
349d385
< 
351,352c387,388
<         measure_bilinear_loops_4spinorfield(prop, source, k, nm, tau, -1, -1,
<                                             out_corr);
---
>         measure_bilinear_loops_4spinorfield(prop, source, k, tau, -1, -1, swc,
>                                             ret);
355a392
> 
357c394
<       for (tau = 0; tau < GLB_T; ++tau) {
---
>       for (tau = 0; tau < GLB_T; ++tau)
362,363c399,400
<           measure_bilinear_loops_4spinorfield(prop, source, k, nm, tau, col, -1,
<                                               out_corr);
---
>           measure_bilinear_loops_4spinorfield(prop, source, k, tau, col, -1,
>                                               swc, ret);
365,366d401
<       }
< 
367a403
> 
370,372c406,407
< 
<       for (tau = 0; tau < GLB_T; ++tau) {
<         for (col = 0; col < NF; ++col) {
---
>       for (tau = 0; tau < GLB_T; ++tau)
>         for (col = 0; col < NF; ++col)
377,380c412,413
<             measure_bilinear_loops_4spinorfield(prop, source, k, nm, tau, col,
<                                                 eo, out_corr);
<           }
<         }
---
>             measure_bilinear_loops_4spinorfield(prop, source, k, tau, col, eo,
>                                                 swc, ret);
382d414
< 
387c419
<       for (col = 0; col < NF; ++col) {
---
>       for (col = 0; col < NF; ++col)
389d420
< 
394,395c425,426
<           measure_bilinear_loops_4spinorfield(prop, source, k, nm, -1, col, eo,
<                                               out_corr);
---
>           measure_bilinear_loops_4spinorfield(prop, source, k, -1, col, eo, swc,
>                                               ret);
397,398d427
<       }
< 
401c430
<   if (source_type == 1) {
---
>   if (u_gauge_old != NULL) {
418,419c447,449
<                                         spinor_field *source, int k, int nm,
<                                         int n_mom, double complex ***out_corr) {
---
>                                         spinor_field *source, int src_id,
>                                         int n_mom, storage_switch swc,
>                                         data_storage_array **ret) {
435c465
<   for (int i = 0; i < n_mom_tot; i++)
---
>   for (i = 0; i < n_mom_tot; i++)
437,438c467,468
<   for (int i = 0; i < n_mom_tot; i++)
<     for (int j = 0; j < NGamma; j++)
---
>   for (i = 0; i < n_mom_tot; i++)
>     for (j = 0; j < NGamma; j++)
448,451d477
<   if (nm != 1)
<     error(nm != 1, 1, "[measure_biliniear_loops_spinorfield]",
<           "Multimass not implemented !");
< 
459,460d484
<   /* loop on nm if the MMS is used */
<   for (i = 0; i < nm; i++) {
463c487
<       tc = (zerocoord[0] + t + GLB_T) % GLB_T + i * GLB_T + offset;
---
>     tc = (zerocoord[0] + t + GLB_T) % GLB_T + offset;
549d572
<   }         /* end loop i (nm) */
572,574c595,597
<       global_sum(corr_re[j][iGamma], GLB_T * nm);
<       global_sum(corr_im[j][iGamma], GLB_T * nm);
<       global_sum((double *)(corr[j][iGamma]), 2 * GLB_T * nm);
---
>       global_sum(corr_re[j][iGamma], GLB_T);
>       global_sum(corr_im[j][iGamma], GLB_T);
>       global_sum((double *)(corr[j][iGamma]), 2 * GLB_T);
577c600
<   if (k == 0)
---
>   if (src_id == 0)
589c612
<                     k, px, py, pz, corr_re[ip][iGamma][t],
---
>                     src_id, px, py, pz, corr_re[ip][iGamma][t],
591,594c614,619
<             if (out_corr != NULL)
<               out_corr[ip][iGamma][t] +=
<                   creal(corr[ip][iGamma][t]) + I * cimag(corr[ip][iGamma][t]);
<             ip = ip + 1;
---
> 
>             if (swc == STORE) {
>               int idx[5] = {src_id, ip, iGamma, t, 0};
>               *data_storage_element(*ret, 0, idx) = corr_re[ip][iGamma][t];
>               idx[4] = 1;
>               *data_storage_element(*ret, 0, idx) = corr_im[ip][iGamma][t];
596a622,625
>       //	out_corr[ip][iGamma][t] += creal(corr[ip][iGamma][t]) + I *
>       //cimag(corr[ip][iGamma][t]);
>       ip = ip + 1;
>     }
601c630
<           k, etime.tv_sec, etime.tv_usec);
---
>           src_id, etime.tv_sec, etime.tv_usec);
603,604c632,633
<   for (int i = 0; i < n_mom_tot; i++)
<     for (int j = 0; j < NGamma; j++)
---
>   for (i = 0; i < n_mom_tot; i++)
>     for (j = 0; j < NGamma; j++)
607c636
<   for (int i = 0; i < n_mom_tot; i++)
---
>   for (i = 0; i < n_mom_tot; i++)
** LibHR/Observables/measure_baryons.c
140c140,141
< void contract_baryons(spinor_field *psi0, int tau) {
---
> void contract_baryons(spinor_field *psi0, int tau, storage_switch swc,
>                       data_storage_array **ret) {
** LibHR/Observables/measure_scattering.c
43c43
< int tsplit(int ipt, int delta) {
---
> int tsplit(int ipt_in, int delta) {
45c45
<     return iup(ipt, 0);
---
>     return iup(ipt_in, 0);
47c47
<     return idn(ipt, 0);
---
>     return idn(ipt_in, 0);
49c49
<     return ipt;
---
>     return ipt_in;
** LibHR/Observables/measure_scattering_tools.c
1328d1327
<     for (int src = 0; src < numsources; src++)
** LibHR/Observables/meson_measurements.c
102c102,103
<                          double precision) {
---
>                          double precision, storage_switch swc,
>                          data_storage_array **ret) {
104a106,117
>   for (int i = 0; i < 4 * nm * NF; i++)
>     spinor_field_zero_f(prop + i);
> 
>   // init data storage here
>   if (swc == STORE) {
>     int idx[5] = {nm, pow(n_mom, 3), 16, GLB_T, 2};
>     *ret = allocate_data_storage_array(1);
>     allocate_data_storage_element(
>         *ret, 0, 5, idx); // ( 1 ) * (nmom^3*ngamma*GLB_T * 2 reals )
>     lprintf("MAIN", 0, "data_storage_element allocated !\n");
>   }
> 
119a133,175
>   if (swc == STORE) {
> 
>     double norm = -(1. / GLB_VOL3);
>     meson_observable *motmp = meson_correlators;
> 
>     int iG = 0;
>     while (motmp != NULL) {
> 
>       global_sum(motmp->corr_re, motmp->corr_size);
>       global_sum(motmp->corr_im, motmp->corr_size);
>       for (int i = 0; i < motmp->corr_size; i++) {
>         motmp->corr_re[i] *= norm;
>         motmp->corr_im[i] *= norm;
>       }
>       int ip = 0;
>       for (int px = 0; px < n_mom; ++px)
>         for (int py = 0; py < n_mom; ++py)
>           for (int pz = 0; pz < n_mom; ++pz) {
>             for (int im = 0; im < nm; im++) {
>               if (motmp->ind1 == motmp->ind2) {
>                 for (int t = 0; t < GLB_T; ++t) {
>                   lprintf(
>                       "MAIN", 0,
>                       "(px,py,pz) = (%d,%d,%d), im = %d, ip =%d, iG=%d, t=%d  "
>                       "%3.10e\n",
>                       px, py, pz, im, ip, iG, t,
>                       motmp->corr_re[corr_ind(px, py, pz, n_mom, t, nm, im)]);
>                   int idx[5] = {im, ip, iG, t, 0};
>                   *data_storage_element(*ret, 0, idx) =
>                       motmp->corr_re[corr_ind(px, py, pz, n_mom, t, nm, im)];
>                   idx[4] = 1;
>                   *data_storage_element(*ret, 0, idx) =
>                       motmp->corr_im[corr_ind(px, py, pz, n_mom, t, nm, im)];
>                 }
>               }
>             }
>             ip += 1;
>           }
>       iG += 1;
>       motmp = motmp->next;
>     }
>   }
> 
131c187,188
<                              int conf_num, double precision) {
---
>                              int conf_num, double precision, storage_switch swc,
>                              data_storage_array **ret) {
135a193,196
> 
>   for (int i = 0; i < 8 * nm; i++)
>     spinor_field_zero_f(prop_p + i);
> 
177c238,239
<                                  int conf_num, double precision) {
---
>                                  int conf_num, double precision,
>                                  storage_switch swc, data_storage_array **ret) {
181a244,246
> 
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
213c278,279
<                                         double Q, int n) {
---
>                                         double Q, int n, storage_switch swc,
>                                         data_storage_array **ret) {
216a283,288
> 
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop_u + i);
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop_d + i);
> 
231c303,304
<     calc_propagator_eo(prop_u, source, 4); // 4 for spin dilution
---
>     calc_propagator_eo(prop_u, source,
>                        4); // 4 for spin dilution
255c328,329
<                               double precision) {
---
>                               double precision, storage_switch swc,
>                               data_storage_array **ret) {
257a332,343
> 
>   // init data storage here
>   if (swc == STORE) {
>     int idx[4] = {nm, 16, GLB_T, 2};
>     *ret = allocate_data_storage_array(1);
>     allocate_data_storage_element(
>         *ret, 0, 4, idx); // ( 1 ) * (nmom^3*ngamma*GLB_T * 2 reals )
>     lprintf("MAIN", 0, "data_storage_element allocated !\n");
>   }
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
> 
264a351,384
> 
>   if (swc == STORE) {
> 
>     double norm = -(1. / (nhits * GLB_VOL3 / 2.)) / GLB_VOL3;
>     meson_observable *motmp = meson_correlators;
> 
>     int iG = 0;
>     while (motmp != NULL) {
> 
>       global_sum(motmp->corr_re, motmp->corr_size);
>       global_sum(motmp->corr_im, motmp->corr_size);
>       for (int i = 0; i < motmp->corr_size; i++) {
>         motmp->corr_re[i] *= norm;
>         motmp->corr_im[i] *= norm;
>       }
>       for (int im = 0; im < nm; im++) {
>         if (motmp->ind1 == motmp->ind2) {
>           for (int t = 0; t < GLB_T; ++t) {
>             lprintf("MAIN", 0, " im = %d, iG=%d, t=%d  %3.10e\n", im, iG, t,
>                     motmp->corr_re[corr_ind(0, 0, 0, 1, t, nm, im)]);
>             int idx[4] = {im, iG, t, 0};
>             *data_storage_element(*ret, 0, idx) =
>                 motmp->corr_re[corr_ind(0, 0, 0, 1, t, nm, im)];
>             idx[3] = 1;
>             *data_storage_element(*ret, 0, idx) =
>                 motmp->corr_im[corr_ind(0, 0, 0, 1, t, nm, im)];
>           }
>         }
>       }
>       iG += 1;
>       motmp = motmp->next;
>     }
>   }
> 
273c393,394
<                                   double precision) {
---
>                                   double precision, storage_switch swc,
>                                   data_storage_array **ret) {
277a399,402
> 
>   for (int i = 0; i < 8 * nm; i++)
>     spinor_field_zero_f(prop_p + i);
> 
306c431,433
<                                       int conf_num, double precision) {
---
>                                       int conf_num, double precision,
>                                       storage_switch swc,
>                                       data_storage_array **ret) {
310a438,441
> 
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
> 
333,334c464,465
< void measure_spectrum_gfwall(int nm, double *m, int conf_num,
<                              double precision) {
---
> void measure_spectrum_gfwall(int nm, double *m, int conf_num, double precision,
>                              storage_switch swc, data_storage_array **ret) {
338a470,471
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
374c507,508
<                                      double precision) {
---
>                                      double precision, storage_switch swc,
>                                      data_storage_array **ret) {
378a513,514
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
422c558,559
<                                      double precision) {
---
>                                      double precision, storage_switch swc,
>                                      data_storage_array **ret) {
424a562,564
> 
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
447c587,588
<                                     double precision) {
---
>                                     double precision, storage_switch swc,
>                                     data_storage_array **ret) {
450a592,595
> 
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
> 
490c635,637
<                                     double precision, int dil) {
---
>                                     double precision, int dil,
>                                     storage_switch swc,
>                                     data_storage_array **ret) {
494a642,644
>   for (int i = 0; i < 4 * nm; i++)
>     spinor_field_zero_f(prop + i);
> 
514c664,665
<                            int conf_num, double precision) {
---
>                            int conf_num, double precision, storage_switch swc,
>                            data_storage_array **ret) {
525a677,681
>   for (int i = 0; i < 4 * NF; i++) {
>     spinor_field_zero_f(prop_i + i);
>     spinor_field_zero_f(prop_seq + i);
>   }
> 
549c705,706
<                               int n_mom, int conf_num, double precision) {
---
>                               int n_mom, int conf_num, double precision,
>                               storage_switch swc, data_storage_array **ret) {
570a728,732
> 
>   for (int i = 0; i < 4 * NF; i++) {
>     spinor_field_zero_f(prop_i + i);
>     spinor_field_zero_f(prop_seq + i);
>   }
** LibHR/Observables/meson_measurements_ff.c
8a9
> #include "data_storage.h"
99c100,101
<                             double precision) {
---
>                             double precision, storage_switch swc,
>                             data_storage_array **ret) {
142c144,145
<                                  double precision) {
---
>                                  double precision, storage_switch swc,
>                                  data_storage_array **ret) {
168c171,172
<                                      double precision) {
---
>                                      double precision, storage_switch swc,
>                                      data_storage_array **ret) {
227c231,233
<                                         int conf_num, double precision) {
---
>                                         int conf_num, double precision,
>                                         storage_switch swc,
>                                         data_storage_array **ret) {
** LibHR/Observables/sources.c
106c106,107
<   if (COORD[0] == tau / T && COORD[1] == 0 && COORD[2] == 0 && COORD[3] == 0) {
---
>   if (zerocoord[0] <= tau && tau < zerocoord[0] + T && COORD[1] == 0 &&
>       COORD[2] == 0 && COORD[3] == 0) {
127,128c128,130
<   if (COORD[0] == t / T && COORD[1] == x / X && COORD[2] == y / Y &&
<       COORD[3] == z / Z) {
---
>   if (zerocoord[0] <= t && t < zerocoord[0] + T && zerocoord[1] <= x &&
>       x < zerocoord[1] + X && zerocoord[2] <= y && y < zerocoord[2] + Y &&
>       zerocoord[3] <= z && z < zerocoord[3] + Z) {
276,277c278,280
<   if (COORD[0] == tau / T) { // Check that tau is in this thread.
<     c[0] = tau % T;
---
>   if (zerocoord[0] <= tau &&
>       tau < zerocoord[0] + T) { // Check that tau is in this thread.
>     c[0] = tau - zerocoord[0];
** LibHR/Observables/z2semwall.c
224c224,225
<                                    spinor_field *psi, spinor_field *eta) {
---
>                                    spinor_field *psi_out,
>                                    spinor_field *eta_in) {
251c252
<   (*Gamma)(_FIELD_AT(eta2, ix), _FIELD_AT(eta, ix));
---
>   (*Gamma)(_FIELD_AT(eta2, ix), _FIELD_AT(eta_in, ix));
270,271c271,272
<             "g5QMR_eo residuum of source Gamma(eta)+QMR_noise [%d] = %e\n", i,
<             norm);
---
>             "g5QMR_eo residuum of source Gamma(eta_in)+QMR_noise [%d] = %e\n",
>             i, norm);
289c290
<             "g5QMR_eo residuum of source Gamma(eta) [%d] = %e\n", i, norm);
---
>             "g5QMR_eo residuum of source Gamma(eta_in) [%d] = %e\n", i, norm);
294c295
<     qprop_mask = psi[i];
---
>     qprop_mask = psi_out[i];
296c297
<     /* qprop_mask.ptr=psi[i].ptr+glat_even.master_shift; */
---
>     /* qprop_mask.ptr=psi_out[i].ptr+glat_even.master_shift; */
299c300
<     qprop_mask.ptr = psi[i].ptr + glat_odd.master_shift;
---
>     qprop_mask.ptr = psi_out[i].ptr + glat_odd.master_shift;
309c310
<     D(&test[0], &psi[i]);
---
>     D(&test[0], &psi_out[i]);
313c314
<     (*Gamma)(_FIELD_AT(&test[1], ix), _FIELD_AT(eta, ix));
---
>     (*Gamma)(_FIELD_AT(&test[1], ix), _FIELD_AT(eta_in, ix));
317c318,319
<             "g5QMR_eo residuum of source Gamma(eta) (2) [%d] = %e\n", i, norm);
---
>             "g5QMR_eo residuum of source Gamma(eta_in) (2) [%d] = %e\n", i,
>             norm);
** LibHR/Observables/z2semwall_new.c
183c183,184
< static void z2semwall_qprop_QMR_eo(spinor_field *psi, spinor_field *eta) {
---
> static void z2semwall_qprop_QMR_eo(spinor_field *psi_out,
>                                    spinor_field *eta_in) {
186c187
<   lprintf("ZSEMWALL", 0, "%g\n", spinor_field_sqnorm_f(eta));
---
>   lprintf("ZSEMWALL", 0, "%g\n", spinor_field_sqnorm_f(eta_in));
191c192
<   spinor_field_add_f(eta2, eta, QMR_noise);
---
>   spinor_field_add_f(eta2, eta_in, QMR_noise);
193c194
<   spinor_field_copy_f(eta2, eta);
---
>   spinor_field_copy_f(eta2, eta_in);
207c208
<     qprop_mask = psi[i];
---
>     qprop_mask = psi_out[i];
209c210
<     /* qprop_mask.ptr=psi[i].ptr+glat_even.master_shift; */
---
>     /* qprop_mask.ptr=psi_out[i].ptr+glat_even.master_shift; */
212c213
<     qprop_mask.ptr = psi[i].ptr + glat_odd.master_shift;
---
>     qprop_mask.ptr = psi_out[i].ptr + glat_odd.master_shift;
220c221
<   lprintf("ZSEMWALL", 0, "%g\n", spinor_field_sqnorm_f(eta));
---
>   lprintf("ZSEMWALL", 0, "%g\n", spinor_field_sqnorm_f(eta_in));
** LibHR/Random/ranlxd.c
43a44
> #include "global.h"
50a52,77
> static void local_error(int no) {
>   switch (no) {
>   case 1:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of luxury level (should be 1 or 2)\n");
>     break;
>   case 2:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
>     break;
>   case 3:
>     printf("Error in rlxd_get\n");
>     printf("Undefined state (ranlxd is not initialized\n");
>     break;
>   case 5:
>     printf("Error in rlxd_reset\n");
>     printf("Unexpected input data\n");
>     break;
>   case 6:
>     printf("Unitialized random seed\n");
>     break;
>   }
>   printf("Program aborted\n");
>   exit(0);
> }
> 
95,117d121
< static void error(int no) {
<   switch (no) {
<   case 1:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of luxury level (should be 1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxd_get\n");
<     printf("Undefined state (ranlxd is not initialized\n");
<     break;
<   case 5:
<     printf("Error in rlxd_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
191c195
<     error(1);
---
>     local_error(1);
193c197
<   i = seed;
---
>   i = seed + MPI_PID;
201c205
<     error(2);
---
>     local_error(2);
243c247
<     rlxd_init(1, 1);
---
>     local_error(6);
260c264
<     error(3);
---
>     local_error(3);
285c289
<     error(5);
---
>     local_error(5);
289c293
<       error(5);
---
>       local_error(5);
298c302
<     error(5);
---
>     local_error(5);
315c319
<     error(5);
---
>     local_error(5);
318a323,597
> #ifdef _OPENMP
> #include "hr_omp.h"
> 
> #define BASE 0x1000000
> #define MASK 0xffffff
> 
> typedef struct {
>   int c1, c2, c3, c4;
> } vec_t;
> 
> typedef struct {
>   vec_t c1, c2;
> } dble_vec_t;
> 
> typedef union {
>   dble_vec_t vec[12];
>   int num[96];
> } x_struct;
> 
> static int *init = NULL, *pr, *prm, *ir, *jr, *is, *is_old, **next;
> static double *one_bit;
> static vec_t *carry;
> static x_struct *x;
> 
> #define STEP(pi, pj, ltid)                                                     \
>   d = (*pj).c1.c1 - (*pi).c1.c1 - carry[ltid].c1;                              \
>   (*pi).c2.c1 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c1 = d & MASK;                                                      \
>   d = (*pj).c1.c2 - (*pi).c1.c2 - carry[ltid].c2;                              \
>   (*pi).c2.c2 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c2 = d & MASK;                                                      \
>   d = (*pj).c1.c3 - (*pi).c1.c3 - carry[ltid].c3;                              \
>   (*pi).c2.c3 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c3 = d & MASK;                                                      \
>   d = (*pj).c1.c4 - (*pi).c1.c4 - carry[ltid].c4;                              \
>   (*pi).c2.c4 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c4 = d & MASK;                                                      \
>   d = (*pj).c2.c1 - (*pi).c2.c1;                                               \
>   carry[ltid].c1 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c1 = d & MASK;                                                      \
>   d = (*pj).c2.c2 - (*pi).c2.c2;                                               \
>   carry[ltid].c2 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c2 = d & MASK;                                                      \
>   d = (*pj).c2.c3 - (*pi).c2.c3;                                               \
>   carry[ltid].c3 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c3 = d & MASK;                                                      \
>   d = (*pj).c2.c4 - (*pi).c2.c4;                                               \
>   carry[ltid].c4 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c4 = d & MASK
> 
> static void update(void) {
>   int k, kmax, d;
>   dble_vec_t *pmin, *pmax, *pi, *pj;
> 
>   int tid = omp_get_thread_num();
> 
>   kmax = pr[tid];
>   pmin = &(x[tid].vec[0]);
>   pmax = pmin + 12;
>   pi = &(x[tid].vec[ir[tid]]);
>   pj = &(x[tid].vec[jr[tid]]);
> 
>   for (k = 0; k < kmax; k++) {
>     STEP(pi, pj, tid);
> 
>     pi += 1;
>     pj += 1;
>     if (pi == pmax)
>       pi = pmin;
>     if (pj == pmax)
>       pj = pmin;
>   }
> 
>   ir[tid] += prm[tid];
>   jr[tid] += prm[tid];
>   if (ir[tid] >= 12)
>     ir[tid] -= 12;
>   if (jr[tid] >= 12)
>     jr[tid] -= 12;
>   is[tid] = 8 * ir[tid];
>   is_old[tid] = is[tid];
> }
> 
> static void define_constants(void) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   one_bit[tid] = ldexp(1.0, -24);
> 
>   for (k = 0; k < 96; k++) {
>     next[tid][k] = (k + 1) % 96;
>     if ((k % 4) == 3)
>       next[tid][k] = (k + 5) % 96;
>   }
> }
> 
> void rlxd_init(int level, int seed) {
>   _OMP_PRAGMA(_omp_parallel) {
>     int tid = omp_get_thread_num();
>     int nt = omp_get_num_threads();
>     _OMP_PRAGMA(single) {
> 
>       init = malloc(nt * sizeof(int));
>       pr = malloc(nt * sizeof(int));
>       prm = malloc(nt * sizeof(int));
>       ir = malloc(nt * sizeof(int));
>       jr = malloc(nt * sizeof(int));
>       is = malloc(nt * sizeof(int));
>       is_old = malloc(nt * sizeof(int));
>       next = malloc(nt * sizeof(int *));
> 
>       one_bit = malloc(nt * sizeof(double));
>       carry = malloc(nt * sizeof(vec_t));
>       x = malloc(nt * sizeof(x_struct));
>     }
>     next[tid] = malloc(96 * sizeof(int));
>     int i, k, l;
>     int ibit, jbit, xbit[31];
>     int ix, iy;
> 
>     if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24) ||
>         (DBL_MANT_DIG < 48))
>       local_error(0);
> 
>     define_constants();
> 
>     if (level == 1)
>       pr[tid] = 202;
>     else if (level == 2)
>       pr[tid] = 397;
>     else
>       local_error(1);
> 
>     i = seed + tid + nt * MPI_PID;
> 
>     for (k = 0; k < 31; k++) {
>       xbit[k] = i % 2;
>       i /= 2;
>     }
> 
>     if ((seed <= 0) || (i != 0))
>       local_error(2);
> 
>     ibit = 0;
>     jbit = 18;
> 
>     for (i = 0; i < 4; i++) {
>       for (k = 0; k < 24; k++) {
>         ix = 0;
> 
>         for (l = 0; l < 24; l++) {
>           iy = xbit[ibit];
>           ix = 2 * ix + iy;
> 
>           xbit[ibit] = (xbit[ibit] + xbit[jbit]) % 2;
>           ibit = (ibit + 1) % 31;
>           jbit = (jbit + 1) % 31;
>         }
> 
>         if ((k % 4) != i)
>           ix = 16777215 - ix;
> 
>         x[tid].num[4 * k + i] = ix;
>       }
>     }
> 
>     carry[tid].c1 = 0;
>     carry[tid].c2 = 0;
>     carry[tid].c3 = 0;
>     carry[tid].c4 = 0;
> 
>     ir[tid] = 0;
>     jr[tid] = 7;
>     is[tid] = 91;
>     is_old[tid] = 0;
>     prm[tid] = pr[tid] % 12;
>     init[tid] = 1;
>   }
> }
> 
> void ranlxd(double r[], int n) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init == NULL)
>     local_error(6);
> 
>   for (k = 0; k < n; k++) {
> 
>     is[tid] = next[tid][is[tid]];
> 
>     if (is[tid] == is_old[tid])
>       update();
>     r[k] = one_bit[tid] * ((double)(x[tid].num[is[tid] + 4]) +
>                            one_bit[tid] * (double)(x[tid].num[is[tid]]));
>   }
> }
> 
> int rlxd_size(void) { return (105); }
> 
> void rlxd_get(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init[tid] == 0)
>     local_error(3);
> 
>   state[0] = rlxd_size();
> 
>   for (k = 0; k < 96; k++)
>     state[k + 1] = x[tid].num[k];
> 
>   state[97] = carry[tid].c1;
>   state[98] = carry[tid].c2;
>   state[99] = carry[tid].c3;
>   state[100] = carry[tid].c4;
> 
>   state[101] = pr[tid];
>   state[102] = ir[tid];
>   state[103] = jr[tid];
>   state[104] = is[tid];
> }
> 
> void rlxd_reset(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
>   if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24) ||
>       (DBL_MANT_DIG < 48))
>     local_error(4);
> 
>   define_constants();
> 
>   if (state[0] != rlxd_size())
>     local_error(5);
> 
>   for (k = 0; k < 96; k++) {
>     if ((state[k + 1] < 0) || (state[k + 1] >= 167777216))
>       local_error(5);
> 
>     x[tid].num[k] = state[k + 1];
>   }
> 
>   if (((state[97] != 0) && (state[97] != 1)) ||
>       ((state[98] != 0) && (state[98] != 1)) ||
>       ((state[99] != 0) && (state[99] != 1)) ||
>       ((state[100] != 0) && (state[100] != 1)))
>     local_error(5);
> 
>   carry[tid].c1 = state[97];
>   carry[tid].c2 = state[98];
>   carry[tid].c3 = state[99];
>   carry[tid].c4 = state[100];
> 
>   pr[tid] = state[101];
>   ir[tid] = state[102];
>   jr[tid] = state[103];
>   is[tid] = state[104];
>   is_old[tid] = 8 * ir[tid];
>   prm[tid] = pr[tid] % 12;
>   init[tid] = 1;
> 
>   if (((pr[tid] != 202) && (pr[tid] != 397)) || (ir[tid] < 0) ||
>       (ir[tid] > 11) || (jr[tid] < 0) || (jr[tid] > 11) ||
>       (jr[tid] != ((ir[tid] + 7) % 12)) || (is[tid] < 0) || (is[tid] > 91))
>     local_error(5);
> }
> #else
374,404d652
< static void error(int no) {
<   switch (no) {
<   case 0:
<     printf("Error in rlxd_init\n");
<     printf("Arithmetic on this machine is not suitable for ranlxd\n");
<     break;
<   case 1:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of luxury level (should be 1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxd_get\n");
<     printf("Undefined state (ranlxd is not initialized)\n");
<     break;
<   case 4:
<     printf("Error in rlxd_reset\n");
<     printf("Arithmetic on this machine is not suitable for ranlxd\n");
<     break;
<   case 5:
<     printf("Error in rlxd_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
454c702
<     error(0);
---
>     local_error(0);
463c711
<     error(1);
---
>     local_error(1);
465c713
<   i = seed;
---
>   i = seed + MPI_PID;
473c721
<     error(2);
---
>     local_error(2);
515c763
<     rlxd_init(1, 1);
---
>     local_error(6);
518a767
> 
520a770
> 
531c781
<     error(3);
---
>     local_error(3);
554c804
<     error(4);
---
>     local_error(4);
559c809
<     error(5);
---
>     local_error(5);
563c813
<       error(5);
---
>       local_error(5);
572c822
<     error(5);
---
>     local_error(5);
589c839
<     error(5);
---
>     local_error(5);
590a841
> #endif
** LibHR/Random/ranlxs.c
43a44
> #include "global.h"
50a52,77
> static void local_error(int no) {
>   switch (no) {
>   case 1:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of luxury level (should be 1 or 2)\n");
>     break;
>   case 2:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
>     break;
>   case 3:
>     printf("Error in rlxd_get\n");
>     printf("Undefined state (ranlxd is not initialized\n");
>     break;
>   case 5:
>     printf("Error in rlxd_reset\n");
>     printf("Unexpected input data\n");
>     break;
>   case 6:
>     printf("Unitialized random seed\n");
>     break;
>   }
>   printf("Program aborted\n");
>   exit(0);
> }
> 
95,117d121
< static void error(int no) {
<   switch (no) {
<   case 1:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of luxury level (should be 0,1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxs_get\n");
<     printf("Undefined state (ranlxs is not initialized\n");
<     break;
<   case 5:
<     printf("Error in rlxs_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
190c194
<     error(1);
---
>     local_error(1);
192c196
<   i = seed;
---
>   i = seed + MPI_PID;
200c204
<     error(2);
---
>     local_error(2);
242,243c246
<     rlxs_init(0, 1);
< 
---
>     local_error(6);
259c262
<     error(3);
---
>     local_error(3);
284c287
<     error(5);
---
>     local_error(5);
288c291
<       error(5);
---
>       local_error(5);
297c300
<     error(5);
---
>     local_error(5);
314c317
<     error(5);
---
>     local_error(5);
317a321,588
> #ifdef _OPENMP
> #include "hr_omp.h"
> 
> #define BASE 0x1000000
> #define MASK 0xffffff
> typedef struct {
>   int c1, c2, c3, c4;
> } vec_t;
> 
> typedef struct {
>   vec_t c1, c2;
> } dble_vec_t;
> 
> typedef union {
>   dble_vec_t vec[12];
>   int num[96];
> } x_struct;
> 
> static int *init = NULL, *pr, *prm, *ir, *jr, *is, *is_old, *next;
> static float *one_bit;
> static vec_t *carry;
> static x_struct *x;
> 
> #define STEP(pi, pj, ltid)                                                     \
>   d = (*pj).c1.c1 - (*pi).c1.c1 - carry[ltid].c1;                              \
>   (*pi).c2.c1 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c1 = d & MASK;                                                      \
>   d = (*pj).c1.c2 - (*pi).c1.c2 - carry[ltid].c2;                              \
>   (*pi).c2.c2 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c2 = d & MASK;                                                      \
>   d = (*pj).c1.c3 - (*pi).c1.c3 - carry[ltid].c3;                              \
>   (*pi).c2.c3 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c3 = d & MASK;                                                      \
>   d = (*pj).c1.c4 - (*pi).c1.c4 - carry[ltid].c4;                              \
>   (*pi).c2.c4 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c4 = d & MASK;                                                      \
>   d = (*pj).c2.c1 - (*pi).c2.c1;                                               \
>   carry[ltid].c1 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c1 = d & MASK;                                                      \
>   d = (*pj).c2.c2 - (*pi).c2.c2;                                               \
>   carry[ltid].c2 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c2 = d & MASK;                                                      \
>   d = (*pj).c2.c3 - (*pi).c2.c3;                                               \
>   carry[ltid].c3 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c3 = d & MASK;                                                      \
>   d = (*pj).c2.c4 - (*pi).c2.c4;                                               \
>   carry[ltid].c4 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c4 = d & MASK
> 
> static void update(void) {
>   int k, kmax, d;
>   dble_vec_t *pmin, *pmax, *pi, *pj;
> 
>   int tid = omp_get_thread_num();
> 
>   kmax = pr[tid];
>   pmin = &(x[tid].vec[0]);
>   pmax = pmin + 12;
>   pi = &(x[tid].vec[ir[tid]]);
>   pj = &(x[tid].vec[jr[tid]]);
> 
>   for (k = 0; k < kmax; k++) {
>     STEP(pi, pj, tid);
> 
>     pi += 1;
>     pj += 1;
>     if (pi == pmax)
>       pi = pmin;
>     if (pj == pmax)
>       pj = pmin;
>   }
> 
>   ir[tid] += prm[tid];
>   jr[tid] += prm[tid];
>   if (ir[tid] >= 12)
>     ir[tid] -= 12;
>   if (jr[tid] >= 12)
>     jr[tid] -= 12;
>   is[tid] = 8 * ir[tid];
>   is_old[tid] = is[tid];
> }
> 
> static void define_constants(void) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   one_bit[tid] = (float)(ldexp(1.0, -24));
> 
>   for (k = 0; k < 96; k++) {
>     next[k + tid * 96] = (k + 1) % 96;
>   }
> }
> 
> void rlxs_init(int level, int seed) {
>   _OMP_PRAGMA(_omp_parallel) {
>     int tid = omp_get_thread_num();
>     int nt = omp_get_num_threads();
>     _OMP_PRAGMA(single) {
>       init = malloc(nt * sizeof(int) * 103);
>       pr = init + nt;
>       prm = pr + nt;
>       ir = prm + nt;
>       jr = ir + nt;
>       is = jr + nt;
>       is_old = is + nt;
>       next = is_old + nt;
> 
>       one_bit = malloc(nt * sizeof(float));
>       carry = malloc(nt * sizeof(vec_t));
>       x = malloc(nt * sizeof(x_struct));
>     }
> 
>     int i, k, l;
>     int ibit, jbit, xbit[31];
>     int ix, iy;
> 
>     if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24))
>       local_error(0);
> 
>     define_constants();
> 
>     if (level == 0)
>       pr[tid] = 109;
>     else if (level == 1)
>       pr[tid] = 202;
>     else if (level == 2)
>       pr[tid] = 397;
>     else
>       local_error(1);
> 
>     i = seed + tid + nt * MPI_PID;
> 
>     for (k = 0; k < 31; k++) {
>       xbit[k] = i % 2;
>       i /= 2;
>     }
> 
>     if ((seed <= 0) || (i != 0))
>       local_error(2);
> 
>     ibit = 0;
>     jbit = 18;
> 
>     for (i = 0; i < 4; i++) {
>       for (k = 0; k < 24; k++) {
>         ix = 0;
> 
>         for (l = 0; l < 24; l++) {
>           iy = xbit[ibit];
>           ix = 2 * ix + iy;
> 
>           xbit[ibit] = (xbit[ibit] + xbit[jbit]) % 2;
>           ibit = (ibit + 1) % 31;
>           jbit = (jbit + 1) % 31;
>         }
> 
>         if ((k % 4) == i)
>           ix = 16777215 - ix;
> 
>         x[tid].num[4 * k + i] = ix;
>       }
>     }
> 
>     carry[tid].c1 = 0;
>     carry[tid].c2 = 0;
>     carry[tid].c3 = 0;
>     carry[tid].c4 = 0;
> 
>     ir[tid] = 0;
>     jr[tid] = 7;
>     is[tid] = 95;
>     is_old[tid] = 0;
>     prm[tid] = pr[tid] % 12;
>     init[tid] = 1;
>   }
> }
> void ranlxs(float r[], int n) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init == NULL)
>     local_error(6);
> 
>   for (k = 0; k < n; k++) {
>     is[tid] = next[is[tid] + tid * 96];
>     if (is[tid] == is_old[tid])
>       update();
>     r[k] = one_bit[tid] * (float)(x[tid].num[is[tid]]);
>   }
> }
> 
> int rlxs_size(void) { return (105); }
> 
> void rlxs_get(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init[tid] == 0)
>     local_error(3);
> 
>   state[0] = rlxs_size();
> 
>   for (k = 0; k < 96; k++)
>     state[k + 1] = x[tid].num[k];
> 
>   state[97] = carry[tid].c1;
>   state[98] = carry[tid].c2;
>   state[99] = carry[tid].c3;
>   state[100] = carry[tid].c4;
> 
>   state[101] = pr[tid];
>   state[102] = ir[tid];
>   state[103] = jr[tid];
>   state[104] = is[tid];
> }
> 
> void rlxs_reset(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24))
>     local_error(4);
> 
>   define_constants();
> 
>   if (state[0] != rlxs_size())
>     local_error(5);
> 
>   for (k = 0; k < 96; k++) {
>     if ((state[k + 1] < 0) || (state[k + 1] >= 167777216))
>       local_error(5);
> 
>     x[tid].num[k] = state[k + 1];
>   }
> 
>   if (((state[97] != 0) && (state[97] != 1)) ||
>       ((state[98] != 0) && (state[98] != 1)) ||
>       ((state[99] != 0) && (state[99] != 1)) ||
>       ((state[100] != 0) && (state[100] != 1)))
>     local_error(5);
> 
>   carry[tid].c1 = state[97];
>   carry[tid].c2 = state[98];
>   carry[tid].c3 = state[99];
>   carry[tid].c4 = state[100];
> 
>   pr[tid] = state[101];
>   ir[tid] = state[102];
>   jr[tid] = state[103];
>   is[tid] = state[104];
>   is_old[tid] = 8 * ir[tid];
>   prm[tid] = pr[tid] % 12;
>   init[tid] = 1;
> 
>   if (((pr[tid] != 109) && (pr[tid] != 202) && (pr[tid] != 397)) ||
>       (ir[tid] < 0) || (ir[tid] > 11) || (jr[tid] < 0) || (jr[tid] > 11) ||
>       (jr[tid] != ((ir[tid] + 7) % 12)) || (is[tid] < 0) || (is[tid] > 95))
>     local_error(5);
> }
> #else
373,403d643
< static void error(int no) {
<   switch (no) {
<   case 0:
<     printf("Error in rlxs_init\n");
<     printf("Arithmetic on this machine is not suitable for ranlxs\n");
<     break;
<   case 1:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of luxury level (should be 0,1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxs_get\n");
<     printf("Undefined state (ranlxs is not initialized)\n");
<     break;
<   case 4:
<     printf("Error in rlxs_reset\n");
<     printf("Arithmetic on this machine is not suitable for ranlxs\n");
<     break;
<   case 5:
<     printf("Error in rlxs_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
449c689
<     error(0);
---
>     local_error(0);
460c700
<     error(1);
---
>     local_error(1);
462c702
<   i = seed;
---
>   i = seed + MPI_PID;
470c710
<     error(2);
---
>     local_error(2);
512c752
<     rlxs_init(0, 1);
---
>     local_error(6);
528c768
<     error(3);
---
>     local_error(3);
550c790
<     error(4);
---
>     local_error(4);
555c795
<     error(5);
---
>     local_error(5);
559c799
<       error(5);
---
>       local_error(5);
568c808
<     error(5);
---
>     local_error(5);
585c825
<     error(5);
---
>     local_error(5);
587c827
< 
---
> #endif
** LibHR/Update/D_ff.c
49,53c49,53
< extern int init_dirac;
< extern spinor_field *gtmp;
< extern spinor_field *etmp;
< extern spinor_field *otmp;
< extern spinor_field *otmp2;
---
> static int init_dirac = 1;
> static spinor_field *gtmp;
> static spinor_field *etmp;
> static spinor_field *otmp;
> static spinor_field *otmp2;
55c55,83
< void init_Dirac();
---
> static void free_mem() {
>   if (gtmp != NULL) {
>     free_spinor_field_f(gtmp);
>     gtmp = NULL;
>   }
>   if (etmp != NULL) {
>     free_spinor_field_f(etmp);
>     etmp = NULL;
>   }
>   if (otmp != NULL) {
>     free_spinor_field_f(otmp);
>     otmp = NULL;
>   }
>   if (otmp2 != NULL) {
>     free_spinor_field_f(otmp2);
>     otmp2 = NULL;
>   }
>   init_dirac = 1;
> }
> static void init_Dirac() {
>   if (init_dirac) {
>     gtmp = alloc_spinor_field_f(1, &glattice);
>     etmp = alloc_spinor_field_f(1, &glat_even);
>     otmp = alloc_spinor_field_f(1, &glat_odd);
>     otmp2 = alloc_spinor_field_f(1, &glat_odd);
>     atexit(&free_mem);
>     init_dirac = 0;
>   }
> }
** LibHR/Update/Dphi.c
39,43c39,43
< int init_dirac = 1;
< spinor_field *gtmp = NULL;
< spinor_field *etmp = NULL;
< spinor_field *otmp = NULL;
< spinor_field *otmp2 = NULL;
---
> static int init_dirac = 1;
> static spinor_field *gtmp = NULL;
> static spinor_field *etmp = NULL;
> static spinor_field *otmp = NULL;
> static spinor_field *otmp2 = NULL;
48c48
<     etmp = NULL;
---
>     gtmp = NULL;
65c65
< void init_Dirac() {
---
> static void init_Dirac() {
173,175c173
<   //  fflush(stdout);
<   //  MPI_Barrier( GLB_COM   );
< 
---
> #ifdef CHECK_SPINOR_MATCHING
178d175
< 
181,183c178
< 
< #ifndef CHECK_SPINOR_MATCHING
<   error(out->type == &glat_even && in->type != &glat_odd, 1, "Dphi_ [Dphi.c]",
---
>   error(out->type == &glat_even && in->type == &glat_even, 1, "Dphi_ [Dphi.c]",
185c180
<   error(out->type == &glat_odd && in->type != &glat_even, 1, "Dphi_ [Dphi.c]",
---
>   error(out->type == &glat_odd && in->type == &glat_odd, 1, "Dphi_ [Dphi.c]",
187,188d181
<   error(out->type == &glattice && in->type != &glattice, 1, "Dphi_ [Dphi.c]",
<         "Spinors don't match! (3)");
364a358,698
> void Dphi_fused_(spinor_field *out, spinor_field *in) {
> #ifdef CHECK_SPINOR_MATCHING
>   error((in == NULL) || (out == NULL), 1, "Dphi_ [Dphi.c]",
>         "Attempt to access unallocated memory space");
>   error(in == out, 1, "Dphi_ [Dphi.c]",
>         "Input and output fields must be different");
>   error(out->type == &glat_even && in->type == &glat_even, 1, "Dphi_ [Dphi.c]",
>         "Spinors don't match! (1)");
>   error(out->type == &glat_odd && in->type == &glat_odd, 1, "Dphi_ [Dphi.c]",
>         "Spinors don't match! (2)");
> #endif
> 
>   //++MVMcounter; /* count matrix calls */
>   // if (out->type == &glattice)
>   //  ++MVMcounter;
>   //
>   /************************ loop over all lattice sites
>    * *************************/
>   /* start communication of input spinor field */
>   _OMP_PRAGMA(master) { start_sf_sendrecv(in); }
>   _OMP_BARRIER
> 
>   int ix;
>   int iy;
>   suNf *up, *um;
>   suNf_vector psi, chi, psi2, chi2;
>   suNf_spinor *r, *sp, *sm;
> #if defined(BC_T_THETA) || defined(BC_X_THETA) || defined(BC_Y_THETA) ||       \
>     defined(BC_Z_THETA)
>   suNf_vector vtmp;
> #endif
> 
>   _OMP_PRAGMA(_omp_for nowait)
>   for (int _fuse_master_for_ip_ix = 0;
>        _fuse_master_for_ip_ix < (out->type)->fuse_inner_counter;
>        _fuse_master_for_ip_ix++) {
> 
>     ix = _FUSE_IDX(out->type, ix);
> 
>     r = _FIELD_AT(out, ix);
> 
>     /******************************* direction +0
>      * *********************************/
> 
>     iy = iup(ix, 0);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 0);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_add_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_T_multiply(chi, (*up), psi);
>     _suNf_theta_T_multiply(chi2, (*up), psi2);
> 
>     (*r).c[0] = chi;
>     (*r).c[2] = chi;
>     (*r).c[1] = chi2;
>     (*r).c[3] = chi2;
> 
>     /******************************* direction -0
>      * *********************************/
> 
>     iy = idn(ix, 0);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 0);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_sub_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_T_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_T_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction +1
>      * *********************************/
> 
>     iy = iup(ix, 1);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 1);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_i_add_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_X_multiply(chi, (*up), psi);
>     _suNf_theta_X_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -1
>      * *********************************/
> 
>     iy = idn(ix, 1);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 1);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_i_sub_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_X_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_X_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +2
>      * *********************************/
> 
>     iy = iup(ix, 2);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 2);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_sub_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_Y_multiply(chi, (*up), psi);
>     _suNf_theta_Y_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -2
>      * *********************************/
> 
>     iy = idn(ix, 2);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 2);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_add_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_Y_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Y_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +3
>      * *********************************/
> 
>     iy = iup(ix, 3);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 3);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_i_sub_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_Z_multiply(chi, (*up), psi);
>     _suNf_theta_Z_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction -3
>      * *********************************/
> 
>     iy = idn(ix, 3);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 3);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_i_add_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_Z_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Z_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************** end of loop
>      * *********************************/
> 
>     _spinor_mul_f(*r, -0.5, *r);
> 
>   } /* FUSE FOR */
> #ifdef WITH_MPI
> 
>   _OMP_PRAGMA(master) { complete_sf_sendrecv(in); }
>   _OMP_PRAGMA(barrier)
> #endif
> 
>   _OMP_PRAGMA(_omp_for nowait)
>   for (int _fuse_master_for_ip_ix = (out->type)->fuse_inner_counter;
>        _fuse_master_for_ip_ix < (out->type)->fuse_gauge_size;
>        _fuse_master_for_ip_ix++) {
>     ix = _FUSE_IDX(out->type, ix);
> 
>     r = _FIELD_AT(out, ix);
> 
>     /******************************* direction +0
>      * *********************************/
> 
>     iy = iup(ix, 0);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 0);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_add_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_T_multiply(chi, (*up), psi);
>     _suNf_theta_T_multiply(chi2, (*up), psi2);
> 
>     (*r).c[0] = chi;
>     (*r).c[2] = chi;
>     (*r).c[1] = chi2;
>     (*r).c[3] = chi2;
> 
>     /******************************* direction -0
>      * *********************************/
> 
>     iy = idn(ix, 0);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 0);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_sub_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_T_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_T_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction +1
>      * *********************************/
> 
>     iy = iup(ix, 1);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 1);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_i_add_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_X_multiply(chi, (*up), psi);
>     _suNf_theta_X_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -1
>      * *********************************/
> 
>     iy = idn(ix, 1);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 1);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_i_sub_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_X_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_X_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +2
>      * *********************************/
> 
>     iy = iup(ix, 2);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 2);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_sub_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_Y_multiply(chi, (*up), psi);
>     _suNf_theta_Y_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -2
>      * *********************************/
> 
>     iy = idn(ix, 2);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 2);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_add_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_Y_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Y_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +3
>      * *********************************/
> 
>     iy = iup(ix, 3);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 3);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_i_sub_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_Z_multiply(chi, (*up), psi);
>     _suNf_theta_Z_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction -3
>      * *********************************/
> 
>     iy = idn(ix, 3);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 3);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_i_add_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_Z_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Z_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************** end of loop
>      * *********************************/
> 
>     _spinor_mul_f(*r, -0.5, *r);
> 
>   } /* FUSE FOR */
> }
> 
538d871
<     init_dirac = 0;
578d910
<     init_dirac = 0;
614d945
<     init_dirac = 0;
637d967
<     init_dirac = 0;
649d978
<     init_dirac = 0;
689d1017
<     init_dirac = 0;
712d1039
<     init_dirac = 0;
917c1244
<  * Cphi = Dphi + clover                          *
---
>  * Cphi = Dphi + exp clover                      *
** LibHR/Update/Dphi_flt.c
45c45
<     etmp = NULL;
---
>     gtmp = NULL;
** LibHR/Update/cabmar.c
44a45,62
> // static inline void rotate(suNg_vector *pu1, suNg_vector *pu2, double *s)
> //{
> //   int i;
> //   double complex *cu1, *cu2;
> //
> //   cu1 = &((*pu1).c[0]);
> //   cu2 = &((*pu2).c[0]);
> //
> //   for (i = 0; i < NG; ++i)
> //   {
> //     (*cu1) = s[0] * (*cu1) + I * s[1] * (*cu2) + s[2] * (*cu2) + I * s[3] *
> //     (*cu1);
> //     (*cu2) = s[0] * (*cu2) + I * s[1] * (*cu1) - s[2] * (*cu1) - I * s[3] *
> //     (*cu2);
> //     ++cu1;
> //     ++cu2;
> //   }
> // }
** LibHR/Update/force0.c
43c43
<   _TWO_SPINORS_MATCHING(u_gauge, par->momenta);
---
>   _TWO_SPINORS_MATCHING(u_gauge, *par->momenta);
** LibHR/Update/force_fermion_core.c
273c273
<       suNf *Z[6], W[9];
---
>       suNf *Zl[6], W[9];
299,304c299,304
<           Z[0] = _6FIELD_AT(cl_force, ix, num);
<           Z[1] = _6FIELD_AT(cl_force, o1, num);
<           Z[2] = _6FIELD_AT(cl_force, o3, num);
<           Z[3] = _6FIELD_AT(cl_force, o4, num);
<           Z[4] = _6FIELD_AT(cl_force, o5, num);
<           Z[5] = _6FIELD_AT(cl_force, o2, num);
---
>           Zl[0] = _6FIELD_AT(cl_force, ix, num);
>           Zl[1] = _6FIELD_AT(cl_force, o1, num);
>           Zl[2] = _6FIELD_AT(cl_force, o3, num);
>           Zl[3] = _6FIELD_AT(cl_force, o4, num);
>           Zl[4] = _6FIELD_AT(cl_force, o5, num);
>           Zl[5] = _6FIELD_AT(cl_force, o2, num);
320,321c320,321
<           _suNf_times_suNf(fmat, W[8], *Z[0]);
<           _suNf_times_suNf(s1, *Z[1], W[8]);
---
>           _suNf_times_suNf(fmat, W[8], *Zl[0]);
>           _suNf_times_suNf(s1, *Zl[1], W[8]);
323c323
<           _suNf_times_suNf(s1, W[0], *Z[2]);
---
>           _suNf_times_suNf(s1, W[0], *Zl[2]);
325c325
<           _suNf_times_suNf(s3, *Z[3], W[6]);
---
>           _suNf_times_suNf(s3, *Zl[3], W[6]);
329c329
<           _suNf_times_suNf(s1, W[2], *Z[4]);
---
>           _suNf_times_suNf(s1, W[2], *Zl[4]);
331c331
<           _suNf_times_suNf(s3, W[7], *Z[5]);
---
>           _suNf_times_suNf(s3, W[7], *Zl[5]);
800,803d799
<     suNg_algebra_vector f;
<     suNf_vector ptmp;
<     suNf_spinor p;
<     suNf_FMAT s1;
813a810,814
>       suNg_algebra_vector f;
>       suNf_vector ptmp;
>       suNf_spinor p;
> 
>       suNf_FMAT s1;
** LibHR/Update/integrators.c
81a82,85
> /* implementation take from "Testing and tuning symplectic integrators for
> Hybrid Monte Carlo algorithm in lattice QCD Tetsuya Takaishia and Philippe de
> Forcrand https://arxiv.org/pdf/hep-lat/0505020.pdf */
> 
83,86c87,90
<   const double r1 = 0.08398315262876693;
<   const double r2 = 0.2539785108410595;
<   const double r3 = 0.6822365335719091;
<   const double r4 = -0.03230286765269967;
---
>   const double rho = 0.1786178958448091;
>   const double theta = -0.06626458266981843;
>   const double lambda = 0.7123418310626056;
> 
101c105
<       monomial_force(r1 * dt, par);
---
>       monomial_force(rho * dt, par);
103c107
<       monomial_force(2 * r1 * dt, par);
---
>       monomial_force(2 * rho * dt, par);
105,113c109,115
<     monomial_field(r2 * dt, par);
<     monomial_force(r3 * dt, par);
<     monomial_field(r4 * dt, par);
<     monomial_force((0.5 - r1 - r3) * dt, par);
<     monomial_field((1 - 2 * (r2 + r4)) * dt, par);
<     monomial_force((0.5 - r1 - r3) * dt, par);
<     monomial_field(r4 * dt, par);
<     monomial_force(r3 * dt, par);
<     monomial_field(r2 * dt, par);
---
>     monomial_field(lambda * dt, par);
>     monomial_force(theta * dt, par);
>     monomial_field((0.5 - lambda) * dt, par);
>     monomial_force((1 - 2 * (theta + rho)) * dt, par);
>     monomial_field((0.5 - lambda) * dt, par);
>     monomial_force(theta * dt, par);
>     monomial_field(lambda * dt, par);
115c117
<   monomial_force(r1 * dt, par);
---
>   monomial_force(rho * dt, par);
** LibHR/Update/mon_hasen_tm_alt.c
** LibHR/Update/monomials.c
29,33c29,33
< static void free_mon_list(mon_list *action) {
<   while (action != NULL) {
<     mon_list *next = action->next;
<     free_mon(action);
<     action = next;
---
> static void free_mon_list(mon_list *actionin) {
>   while (actionin != NULL) {
>     mon_list *next = actionin->next;
>     free_mon(actionin);
>     actionin = next;
** LibHR/Update/mre.c
200c200
< void mre_guess(mre_par *par, int p, spinor_field *out, spinor_operator D,
---
> void mre_guess(mre_par *par, int p, spinor_field *out, spinor_operator DD,
218c218
<     D(Dv, v[i]);
---
>     DD(Dv, v[i]);
** LibHR/Update/random_su2.c
27,31c27,70
< static int i_vec = NVEC, i_y = NRAN, i_v = NRAN;
< static double vec1[NVEC], vec2[NVEC], vec3[NVEC];
< static double r[NRAN], u[NRAN], v[NRAN], y[NRAN];
< 
< static void update_vec(void) {
---
> static int *i_vec = NULL, *i_y, *i_v;
> static double **vec1, **vec2, **vec3;
> static double **r, **u, **v, **y;
> 
> static void init_su2_rand() {
>   int ntd = 1;
> #ifdef _OPENMP
>   ntd = omp_get_num_threads();
>   _OMP_PRAGMA(master) {
>     lprintf("init_su2_rand", 0, "Init rand for threads, performing %d init",
>             ntd);
>   }
> #endif
>   _OMP_PRAGMA(single) {
> 
>     i_vec = malloc(sizeof(int) * ntd);
>     i_y = malloc(sizeof(int) * ntd);
>     i_v = malloc(sizeof(int) * ntd);
> 
>     vec1 = malloc(sizeof(double *) * ntd);
>     vec2 = malloc(sizeof(double *) * ntd);
>     vec3 = malloc(sizeof(double *) * ntd);
>     r = malloc(sizeof(double *) * ntd);
>     u = malloc(sizeof(double *) * ntd);
>     v = malloc(sizeof(double *) * ntd);
>     y = malloc(sizeof(double *) * ntd);
> 
>     for (int i = 0; i < ntd; i++) {
>       i_vec[i] = NVEC;
>       i_y[i] = NRAN;
>       i_v[i] = NRAN;
> 
>       vec1[i] = malloc(sizeof(double) * NVEC);
>       vec2[i] = malloc(sizeof(double) * NVEC);
>       vec3[i] = malloc(sizeof(double) * NVEC);
>       r[i] = malloc(sizeof(double) * NRAN);
>       u[i] = malloc(sizeof(double) * NRAN);
>       v[i] = malloc(sizeof(double) * NRAN);
>       y[i] = malloc(sizeof(double) * NRAN);
>     }
>   }
>   _OMP_BARRIER
> }
> static void update_vec(int tid) {
32a72
> 
35c75
<   ranlxd(r, NRAN);
---
>   ranlxd(r[tid], NRAN);
38,39c78,79
<     r1 = 2.0 * r[i] - 1.0;
<     r2 = TWO_PI * r[NVEC + i] - PI;
---
>     r1 = 2.0 * r[tid][i] - 1.0;
>     r2 = TWO_PI * r[tid][NVEC + i] - PI;
42,44c82,84
<     vec1[i] = r1;
<     vec2[i] = rsq * sin(r2);
<     vec3[i] = rsq * cos(r2);
---
>     vec1[tid][i] = r1;
>     vec2[tid][i] = rsq * sin(r2);
>     vec3[tid][i] = rsq * cos(r2);
47c87
<   i_vec = 0;
---
>   i_vec[tid] = 0;
50c90
< static void update_y(void) {
---
> static void update_y(int tid) {
54,56c94,96
<   ranlxd(y, NRAN);
<   ranlxd(u, NRAN);
<   ranlxd(r, NRAN);
---
>   ranlxd(y[tid], NRAN);
>   ranlxd(u[tid], NRAN);
>   ranlxd(r[tid], NRAN);
59,62c99,102
<     r1 = -log(1.0 - y[i]);
<     r2 = PI_HALF * y[NVEC + i];
<     r3 = log(1.0 - u[i]);
<     r4 = log(1.0 - u[NVEC + i]);
---
>     r1 = -log(1.0 - y[tid][i]);
>     r2 = PI_HALF * y[tid][NVEC + i];
>     r3 = log(1.0 - u[tid][i]);
>     r4 = log(1.0 - u[tid][NVEC + i]);
68,69c108,109
<     y[i] = r1 * s - r3;
<     y[NVEC + i] = r1 * c - r4;
---
>     y[tid][i] = r1 * s - r3;
>     y[tid][NVEC + i] = r1 * c - r4;
71,74c111,114
<     r1 = r[i] * r[i];
<     r2 = r[NVEC + i] * r[NVEC + i];
<     u[i] = r1 + r1;
<     u[NVEC + i] = r2 + r2;
---
>     r1 = r[tid][i] * r[tid][i];
>     r2 = r[tid][NVEC + i] * r[tid][NVEC + i];
>     u[tid][i] = r1 + r1;
>     u[tid][NVEC + i] = r2 + r2;
77c117
<   i_y = 0;
---
>   i_y[tid] = 0;
87a128,129
>   int tid = 0;
> #ifdef _OPENMP
89,91c131,138
<   _OMP_PRAGMA(critical) {
<     if (i_vec == NVEC)
<       update_vec();
---
>   tid = omp_get_thread_num();
> #endif
>   if (i_vec == NULL) {
>     _OMP_BARRIER
>     init_su2_rand();
>   }
>   if (i_vec[tid] == NVEC)
>     update_vec(tid);
97,98c144,145
<         if (i_y == NRAN)
<           update_y();
---
>       if (i_y[tid] == NRAN)
>         update_y(tid);
100,101c147,148
<         s0p1 = 2.0 - rhoinv * y[i_y];
<         ut = u[i_y++];
---
>       s0p1 = 2.0 - rhoinv * y[tid][i_y[tid]];
>       ut = u[tid][i_y[tid]++];
111,113c158,160
<         if (i_v == NRAN) {
<           ranlxd(v, NRAN);
<           i_v = 0;
---
>       if (i_v[tid] == NRAN) {
>         ranlxd(v[tid], NRAN);
>         i_v[tid] = 0;
115,117c162,163
< 
<         s0p1 = rhoinv * log(1.0 + rt * v[i_v++]);
<         ut = v[i_v++];
---
>       s0p1 = rhoinv * log(1.0 + rt * v[tid][i_v[tid]++]);
>       ut = v[tid][i_v[tid]++];
124,126c170,172
<         if (i_v == NRAN) {
<           ranlxd(v, NRAN);
<           i_v = 0;
---
>       if (i_v[tid] == NRAN) {
>         ranlxd(v[tid], NRAN);
>         i_v[tid] = 0;
129c175
<         s0p1 = 2.0 * v[i_v++];
---
>       s0p1 = 2.0 * v[tid][i_v[tid]++];
131c177
<         ut = v[i_v++];
---
>       ut = v[tid][i_v[tid]++];
140,142c186,188
<     s1 = sq * vec1[i_vec];
<     s2 = sq * vec2[i_vec];
<     s3 = sq * vec3[i_vec];
---
>   s1 = sq * vec1[tid][i_vec[tid]];
>   s2 = sq * vec2[tid][i_vec[tid]];
>   s3 = sq * vec3[tid][i_vec[tid]];
152,153c198
<     i_vec += 1;
<   } // OMP Critical section
---
>   i_vec[tid] += 1;
** LibHR/Update/staples.c
23,25c23,25
<   static suNg staple, tr1, tr2;
<   static suNg *p1, *p2, *p3;
<   static int nu, i, ixpmu, ixpnu, ixmnu, ixpmumnu;
---
>   suNg staple, tr1, tr2;
>   suNg *p1, *p2, *p3;
>   int nu, i, ixpmu, ixpnu, ixmnu, ixpmumnu;
** LibHR/Update/updated_hb_multilevel.c
240c240,241
<                                      int *ml_up, int *ml_skip, int nblocking,
---
>                                      int *ml_up, int *ml_skip,
>                                      int nblockingstart, int nblockingend,
245a247
>   int nblocking = nblockingend - nblockingstart + 1;
269c271,272
<                                       nblocking, smear_val, lcor);
---
>                                       nblockingstart, nblockingend, smear_val,
>                                       lcor);
276c279,280
<       measure_1pt_glueballs(nblocking, smear_val, one_point_gb);
---
>       measure_1pt_glueballs(nblockingstart, nblockingend, smear_val,
>                             one_point_gb);
** LibHR/Utils/TMPL/suN_exp.c.tmpl
11c11
< #error : Mismatch between NG and ExpX!
---
> #error : Mismatch between NG and ExpX_legacy!
29c29
<  *  Applica la rotazione di SU(2) definita da
---
>  *  Applies the SU(2) rotation defined by
31c31
<  *  al vettore (v1,v2)
---
>  *  to the (v1,v2) vector
43c43
<  *  Approssima
---
>  *  Approximate
45,47c45,47
<  *  con una matrice unitaria secondo l'algoritmo di Luscher
<  *  e sostituisce
<  *  V.U -> U
---
>  *  with a unitary matrix according to the alghorithm defined in Appendix A
>  *  of https://arxiv.org/pdf/hep-lat/0409106.pdf
>  *  and replaces  V.U -> U
48a49,51
> /*Antonio: The lagacy functions have been left in the file for past reference,
>  * although at the moment they are not used and are meant to be removed.*/
> 
50,51c53,54
< void ExpX(double dt, suNg_algebra_vector *h, suNg *r) {
<   error(0 == 0, 1, "ExpX [suN_epx.c]",
---
> void ExpX_legacy(double dt, suNg_algebra_vector *h, suNg *r) {
>   error(0 == 0, 1, "ExpX_legacy [suN_epx.c]",
55c58
< void ExpX(double dt, suNg_algebra_vector *h, suNg *u) {
---
> void ExpX_legacy(double dt, suNg_algebra_vector *h, suNg *u) {
74c77
< void ExpX2(double dt, suNg_algebra_vector *h, suNg *u) {
---
> void ExpX_legacy2(double dt, suNg_algebra_vector *h, suNg *u) {
** LibHR/Utils/clover_exp.c
340c340
< void clover_exp_taylor(suNfc *X, suNfc *u) {
---
> void clover_exp_taylor(suNfc *Xin, suNfc *u) {
349c349
<     _su2Nfc_times_su2Nfc(tmp, Xk, X);
---
>     _su2Nfc_times_su2Nfc(tmp, Xk, Xin);
** LibHR/Utils/inv_hermNg.c
118,119c118,119
<       for (int i = j + 1; i < N; ++i) {
<         a[i * N + j] = csum * a[i * N + j];
---
>       for (int i1 = j + 1; i1 < N; ++i1) {
>         a[i1 * N + j] = csum * a[i1 * N + j];
** LibHR/Utils/shift_fields.c
0a1,6
> /*
> Routine to geometrically shift the fields (both spinor and/or gauge)
> The routine is MPI friendly and allows for any shift size.
> If any input is left null the routine acts only the other field.
> */
> 
35c41
<     if (sin->type == &glattice)
---
>     if (sin->type == &glattice) {
37,38c43,44
<     else {
<       if (total_shift % 2 == 0)
---
>     } else {
>       if (total_shift % 2 == 0) {
40c46
<       else
---
>       } else
** LibHR/Utils/suN_exp_group.c
42c42
< static void WF_Exp_NG3(suNg *u, suNg *X) {
---
> static void suNg_Exp_NG3(suNg *u, suNg *Xin) {
48a49,50
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
52a55
>   }
54,55c57,58
<   _suNg_times_suNg(X2, *X, *X);
<   _suNg_times_suNg(X3, X2, *X);
---
>   _suNg_times_suNg(X2, *Xin, *Xin);
>   _suNg_times_suNg(X3, X2, *Xin);
79c82
<   _suNg_mul_add(*u, q[0], X0, q[1], *X);
---
>   _suNg_mul_add(*u, q[0], X0, q[1], *Xin);
86c89
< static void WF_Exp_NG4(suNg *u, suNg *X) {
---
> static void suNg_Exp_NG4(suNg *u, suNg *Xin) {
92a96,97
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
96a102,103
>   }
> 
99,101c106,108
<   _suNg_times_suNg(X2, *X, *X);
<   _suNg_times_suNg(X3, X2, *X);
<   _suNg_times_suNg(X4, X3, *X);
---
>   _suNg_times_suNg(X2, *Xin, *Xin);
>   _suNg_times_suNg(X3, X2, *Xin);
>   _suNg_times_suNg(X4, X3, *Xin);
127c134
<   _suNg_mul_add(*u, q[0], X0, q[1], *X);
---
>   _suNg_mul_add(*u, q[0], X0, q[1], *Xin);
136c143
< static void WF_Exp_NG5(suNg *u, suNg *X) {
---
> static void suNg_Exp_NG5(suNg *u, suNg *Xin) {
141a149,150
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
145a155
>   }
149,152c159,162
<   _suNg_times_suNg(X2, *X, *X);
<   _suNg_times_suNg(X3, X2, *X);
<   _suNg_times_suNg(X4, X3, *X);
<   _suNg_times_suNg(X5, X4, *X);
---
>   _suNg_times_suNg(X2, *Xin, *Xin);
>   _suNg_times_suNg(X3, X2, *Xin);
>   _suNg_times_suNg(X4, X3, *Xin);
>   _suNg_times_suNg(X5, X4, *Xin);
180c190
<   _suNg_mul_add(*u, q[0], X0, q[1], *X);
---
>   _suNg_mul_add(*u, q[0], X0, q[1], *Xin);
191c201
< static void WF_Exp_NG6(suNg *u, suNg *X) {
---
> static void suNg_Exp_NG6(suNg *u, suNg *Xin) {
197a208,209
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
201a214
>   }
205,209c218,222
<   _suNg_times_suNg(X2, *X, *X);
<   _suNg_times_suNg(X3, X2, *X);
<   _suNg_times_suNg(X4, X3, *X);
<   _suNg_times_suNg(X5, X4, *X);
<   _suNg_times_suNg(X6, X5, *X);
---
>   _suNg_times_suNg(X2, *Xin, *Xin);
>   _suNg_times_suNg(X3, X2, *Xin);
>   _suNg_times_suNg(X4, X3, *Xin);
>   _suNg_times_suNg(X5, X4, *Xin);
>   _suNg_times_suNg(X6, X5, *Xin);
240c253
<   _suNg_mul_add(*u, q[0], X0, q[1], *X);
---
>   _suNg_mul_add(*u, q[0], X0, q[1], *Xin);
260c273
< static void WF_Exp_NG2(suNg *u, suNg *X) {
---
> static void suNg_Exp_NG2(suNg *u, suNg *Xin) {
263,265c276,278
<   h.c[0] = cimag(X->c[1]);
<   h.c[1] = creal(X->c[1]);
<   h.c[2] = cimag(X->c[0]);
---
>   h.c[0] = cimag(Xin->c[1]);
>   h.c[1] = creal(Xin->c[1]);
>   h.c[2] = cimag(Xin->c[0]);
283c296
< void WF_Exp_Taylor(suNg *u, suNg *X) {
---
> void suNg_Exp_Taylor(suNg *u, suNg *Xin) {
291c304
<     _suNg_times_suNg(tmp, Xk, *X);
---
>     _suNg_times_suNg(tmp, Xk, *Xin);
302c315
< inline void WF_Exp(suNg *u, suNg *X) {
---
> inline void suNg_Exp(suNg *u, suNg *Xin) {
304c317
<   WF_Exp_NG2(u, X);
---
>   suNg_Exp_NG2(u, Xin);
306c319
<   WF_Exp_NG3(u, X);
---
>   suNg_Exp_NG3(u, Xin);
308c321
<   WF_Exp_NG4(u, X);
---
>   suNg_Exp_NG4(u, Xin);
310c323
<   WF_Exp_NG5(u, X);
---
>   suNg_Exp_NG5(u, Xin);
312c325
<   WF_Exp_NG6(u, X);
---
>   suNg_Exp_NG6(u, Xin);
314c327
<   WF_Exp_Taylor(u, X);
---
>   suNg_Exp_Taylor(u, Xin);
316a330,357
> 
> #ifdef GAUGE_SON
> void ExpX(double dt, suNg_algebra_vector *h, suNg *r) {
>   error(0 == 0, 1, "ExpX [suN_epx.c]",
>         "This function has yet not been implementd for SON");
> }
> #else
> void ExpX(double dt, suNg_algebra_vector *h, suNg *u) {
> #ifdef WITH_QUATERNIONS
>   suNg v_tmp, u_tmp;
> 
>   u_tmp = *u;
>   _suNg_exp(dt, *h, v_tmp);
>   _suNg_times_suNg(*u, v_tmp, u_tmp);
> #else // WITH_QUATERNIONS
>   suNg tmp1, tmp2;
> 
>   _fund_algebra_represent(tmp1, *h);
>   _suNg_mul(tmp1, dt, tmp1);
> 
>   suNg_Exp(&tmp2, &tmp1);
>   tmp1 = *u;
> 
>   _suNg_times_suNg(*u, tmp2, tmp1);
> 
> #endif // WITH_QUATERNIONS
> }
> #endif
\ No newline at end of file
** LibHR/Utils/wilsonflow.c
24c24
< static suNg_field *u_gauge_backup = NULL;
---
> static suNg_field *Vtmp = NULL;
37c37
<     u_gauge_backup = alloc_gfield(&glattice);
---
>     Vtmp = alloc_gfield(&glattice);
41d40
<     // int ix, iy, iz, index, mu, nu;
46c45
< 
---
> #ifdef BC_T_OPEN
47a47
> #endif
61,65d60
<   if (wf_plaq_weight == NULL) {
<     wf_plaq_weight = malloc(sizeof(double) * glattice.gsize_gauge * 16);
<     for (index = 0; index < glattice.gsize_gauge * 16; index++)
<       wf_plaq_weight[index] = 1.0;
<   }
73,75c68,69
<             mu = 0;
<             for (nu = mu + 1; nu < 4; nu++) {
<               wf_plaq_weight[index * 16 + mu * 4 + nu] *= *wf_chi * *wf_chi;
---
>             nu = 0;
>             for (mu = nu + 1; mu < 4; mu++) {
78,84c72
<             // for (mu = 1; mu < 3; mu++)
<             //   for (nu = mu + 1; nu < 4; nu++)
<             //   {
<             //     wf_plaq_weight[index * 16 + mu * 4 + nu] /= *wf_chi;
<             //     wf_plaq_weight[index * 16 + nu * 4 + mu] /= *wf_chi;
<             //   }
<           } //
---
>           }
99c87
<     free_gfield(u_gauge_backup);
---
>     free_gfield(Vtmp);
204c192
<       WF_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
---
>       suNg_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
218c206
< double max_distance(suNg_field *V, suNg_field *Vprime) {
---
> double max_distance(suNg_field *V, suNg_field *Vprimel) {
230c218
<       _suNg_sub_assign(diff, *_4FIELD_AT(Vprime, ix, mu));
---
>       _suNg_sub_assign(diff, *_4FIELD_AT(Vprimel, ix, mu));
245d232
<   suNg_field_copy(u_gauge_backup, u_gauge);
246a234
>   suNg_field_copy(Vtmp, V);
266c254
<       WF_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
---
>       suNg_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
288,289c276,277
<       WF_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
<       WF_Exp(&utmp[2], _4FIELD_AT(ws_gf_tmp, ix, mu));
---
>       suNg_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
>       suNg_Exp(&utmp[2], _4FIELD_AT(ws_gf_tmp, ix, mu));
316c304
<       WF_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
---
>       suNg_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
333c321
<     suNg_field_copy(u_gauge, u_gauge_backup);
---
>     suNg_field_copy(V, Vtmp);
335c323
<     lprintf("WARNING", 0,
---
>     lprintf("WILSONFLOW", 20,
369c357
<       WF_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
---
>       suNg_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
388c376
<       WF_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
---
>       suNg_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
406c394
<       WF_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
---
>       suNg_Exp(&utmp[0], _4FIELD_AT(ws_gf, ix, mu));
436,439d423
< 
< #ifdef PLAQ_WEIGHTS
<   *ret *= wf_plaq_weight[ix * 16 + nu * 4 + mu];
< #endif
450c434
<         E += ((double)NG) - p;
---
>         E += NG - p;
478,481d461
< #ifdef PLAQ_WEIGHTS
<             E[2 * gt] +=
<                 ((double)(NG)) * wf_plaq_weight[ix * 16 + nu * 4 + mu] - p;
< #else
483d462
< #endif
488,491d466
< #ifdef PLAQ_WEIGHTS
<               E[2 * gt + 1] +=
<                   ((double)(NG)) * wf_plaq_weight[ix * 16 + nu * 4 + mu] - p;
< #else
493d467
< #endif
496,497c470,471
<     E[2 * gt] /= (3. * GLB_VOL3);
<     E[2 * gt + 1] /= (3. * GLB_VOL3);
---
>     E[2 * gt] /= 0.5 * (GLB_VOL3);
>     E[2 * gt + 1] /= 0.5 * (GLB_VOL3);
523,525d496
< #ifdef PLAQ_WEIGHTS
<   _suNg_mul(w1, wf_plaq_weight[ix * 16 + nu * 4 + mu], w1);
< #endif
539,541d509
< #ifdef PLAQ_WEIGHTS
<   _suNg_mul(w1, wf_plaq_weight[iy * 16 + nu * 4 + mu], w1);
< #endif
556,559d523
< #ifdef PLAQ_WEIGHTS
<   _suNg_mul(w1, wf_plaq_weight[iz * 16 + nu * 4 + mu], w1);
< 
< #endif
573,575d536
< #ifdef PLAQ_WEIGHTS
<   _suNg_mul(w1, wf_plaq_weight[iy * 16 + nu * 4 + mu], w1);
< #endif
632,633c593,594
<     E[2 * gt] *= _FUND_NORM2 / (6. * GLB_VOL3);
<     E[2 * gt + 1] *= _FUND_NORM2 / (6. * GLB_VOL3);
---
>     E[2 * gt] *= _FUND_NORM2 / (GLB_VOL3);
>     E[2 * gt + 1] *= _FUND_NORM2 / (GLB_VOL3);
840d800
<     lprintf("AAA", 0, "entered with eps=%lf\n", epsilon);
854d813
<         lprintf("AAA", 0, "not accepted, change to eps=%lf\n", epsilon_new);
857,858d815
<       lprintf("AAA", 0, "accepted, step of eps=%lf next eps=%lf\n", epsilon,
<               epsilon_new);
868,869d824
<         lprintf("AAA", 0, "measure eps=%lf and meas_eps=%lf\n", epsilon,
<                 epsilon_meas);
879d833
<         lprintf("AAA", 0, "shift for next measure eps=%lf\n", epsilon);
** Make/MkFlags
2c2
< REPR = REPR_FUNDAMENTAL
---
> #REPR = REPR_FUNDAMENTAL
5c5
< #REPR = REPR_ADJOINT
---
> REPR = REPR_ADJOINT
17,18c17,18
< MACRO += -DBC_T_PERIODIC
< #MACRO += -DBC_T_ANTIPERIODIC
---
> #MACRO += -DBC_T_PERIODIC
> MACRO += -DBC_T_ANTIPERIODIC
35c35
< #MACRO += -DWITH_MPI
---
> MACRO += -DWITH_MPI
40c40
< #MACRO += -DCHECK_SPINOR_MATCHING
---
> MACRO += -DCHECK_SPINOR_MATCHING
51,58c51,58
< #CFLAGS = -Wall -std=c99 -O3 -fomit-frame-pointer -msse -msse2 
< CFLAGS = -Wall -std=c99 -O3  #-g #-march=core-avx2 -mtune=core-avx2 -g
< #CFLAGS = -Wall -std=c99 -O3 -qopt-prefetch=4 -qopt-report=2 -march=core-avx2 -mtune=core-avx2
< 
< #CC = gcc-mp-8
< #MPICC = mpicc-mpich-gcc8
< #LDFLAGS =  -L /opt/local/lib/mpich-devel-gcc8/ -L /opt/local/lib/ #-l efence
< #INCLUDE = -I /opt/local/include/mpich-devel-gcc8/ #-I /usr/include
---
> #CFLAGS = -Wall -Wshadow -std=c99 -O3 -fomit-frame-pointer -msse -msse2 
> CFLAGS = -Wall -Wshadow -std=c99 -O3  #-g #-march=core-avx2 -mtune=core-avx2 -g
> #CFLAGS = -Wall -Wshadow -std=c99 -O3 -qopt-prefetch=4 -qopt-report=2 -march=core-avx2 -mtune=core-avx2
> 
> CC = /opt/local/bin/gcc-mp-10
> MPICC = /opt/local/bin/mpicc-mpich-gcc10 
> LDFLAGS = -L /opt/local/lib/mpich-gcc10/ -L /opt/local/lib/ #-l efence
> INCLUDE = -I /opt/local/include/mpich-gcc10/ -I /opt/local/include/ -I /opt/local/include/gcc10/ -I /usr/include
61,64c61,64
< CC = clang-mp-8.0
< MPICC = mpicc-mpich-clang80
< LDFLAGS =  -L /opt/local/lib/mpich-devel-clang80/ -L /opt/local/lib/ #-lefence #-lprofiler #-l efence
< INCLUDE = -I /opt/local/include/mpich-clang80/
---
> #CC = clang
> #MPICC = mpicc
> #LDFLAGS =  #-L /opt/local/lib/mpich-devel-clang80/ -L /opt/local/lib/ #-lefence #-lprofiler #-l efence
> #INCLUDE = #-I /opt/local/include/mpich-clang80/
** Make/Utils/Math_glueballs/OpProjection.m
193c193
<   Module[{psx1, psy1, psz1, psx2, psy2, psz2, psxout, psyout, pszout, irnameout, irname1, irname2, stringout, string1, string2, s1, s2, string},
---
>   Module[{psx1, psy1, psz1, psx2, psy2, psz2, psxout, psyout, pszout, irnameout, irname1, irname2, stringout, string1, string2, s1, s2, string,step},
252c252
< Add2trOpCorrelators[path1_,px1_, py1_, pz1_, irrepidx1_,charge1_, path2_,px2_, py2_, pz2_, irrepidx2_, charge2_,pxout_, pyout_, pzout_, irrepidxout_, irrepevout_]:= Module[{aa,res,success=0,CG,irname1,irname2,irnameout,cg,lridx1,lridx2,lchg1,lchg2,lpath1,lpath2,lres,cg1,i,cc,lpx1,lpy1,lpz1,lpx2,lpy2,lpz2,lev1,lev2,charge=charge1*charge2,tmp,res1,res2,oo,psx1, psy1, psz1, psx2, psy2, psz2},
---
> Add2trOpCorrelators[path1_,px1_, py1_, pz1_, irrepidx1_,charge1_, path2_,px2_, py2_, pz2_, irrepidx2_, charge2_,pxout_, pyout_, pzout_, irrepidxout_, irrepevout_]:= Module[{aa,res,success=0,CG,irname1,irname2,irnameout,cg,lridx1,lridx2,lchg1,lchg2,lpath1,lpath2,lres,cg1,i,cc,lpx1,lpy1,lpz1,lpx2,lpy2,lpz2,lev1,lev2,charge=charge1*charge2,tmp,res1,res2,oo,psx1, psy1, psz1, psx2, psy2, psz2,str},
484c484
< OpSimplify[a_] := Module[{ris = a, Ptemp, tmpris, i, normalization, sqrt},
---
> OpSimplify[ain_] := Module[{ris = ain, Ptemp, tmpris, i, normalization, sqrt},
494c494
<   ris = a //. P -> Ptemp;
---
>   ris = ain //. P -> Ptemp;
507c507
< PathUniqueIdentifier[a_] := PathUniqueIdentifier[a] = Module[{ris = a,res, Ptemp, tmpris, lper,listris,r3},
---
> PathUniqueIdentifier[ain_] := PathUniqueIdentifier[ain] = Module[{ris = ain,res, Ptemp, tmpris, lper,listris,r3},
510a511
>   If[Not[SameQ[(ris //. P :> Plus),0]] ,Print["Requested PathUniqueIdentifier of a non closed Path "];Abort[]];
538c539
< PathUniqueIdentifier[a]]
---
> PathUniqueIdentifier[ain]]
541c542
< PathUniqueIndex[a_]:= PathUniqueIdentifier[a][[2]];
---
> PathUniqueIndex[ain_]:= PathUniqueIdentifier[ain][[2]];
545,546c546,547
< MyCForm[a_] := Module[{res, res1},
<    res = ToCCodeString[CExpression[a]];
---
> MyCForm[ain_] := Module[{res, res1},
>    res = ToCCodeString[CExpression[ain]];
578c579
<               OpTmp=ExpandAll[OpTmp//.Op[a__]:>rotfun[MapOptoCindex[a]]];
---
>               OpTmp=ExpandAll[OpTmp//.Op[la__]:>rotfun[MapOptoCindex[la]]];
580c581
<               RMatrixOp=ExpandAll[RMatrixOp//.Op[a__]:>unrotfun[MapOptoCindex[a]]];
---
>               RMatrixOp=ExpandAll[RMatrixOp//.Op[la__]:>unrotfun[MapOptoCindex[la]]];
672c673
<           lpath = lpath //.  a1_. a_[A__][b__] :> {A} ;
---
>           lpath = lpath //.  a1_. la_[A__][b__] :> {A} ;
934d934
<     MPI_Status r1, r2;
936a937
>     MPI_Request req_1pt[GLB_T];
941d941
< 
947,948d946
< 
< 
952a951
>                 listsent[lcor->list[icor].t1] = 0;
959c958
<                     MPI_Send((double*)(gb_storage + t1 * total_n_glue_op * nblocking), total_n_glue_op * nblocking * 2, MPI_DOUBLE, 0, lcor->list[icor].t1, cart_comm);
---
>                     MPI_Isend((double *)(gb_storage + t1 * total_n_glue_op * nblocking), total_n_glue_op * nblocking * 2, MPI_DOUBLE, 0, lcor->list[icor].t1, cart_comm, req_1pt + lcor->list[icor].t1);
965c964,965
<                 MPI_Recv((double*)(gb1), total_n_glue_op * nblocking * 2, MPI_DOUBLE, t_to_proc[lcor->list[icor].t1], lcor->list[icor].t1, cart_comm, &r1);
---
>                 MPI_Irecv((double *)(gb1), total_n_glue_op * nblocking * 2, MPI_DOUBLE, t_to_proc[lcor->list[icor].t1], lcor->list[icor].t1, cart_comm, req_1pt + lcor->list[icor].t1);
>                 listsent[lcor->list[icor].t1] = 1;
967d966
<             listsent[lcor->list[icor].t1] = 0;
970,971d968
<       if (lcor->list[icor].t1 != lcor->list[icor].t2)
<         {
973a971
>             listsent[lcor->list[icor].t2] = 0;
982c980
<                         MPI_Send((double*)(gb_storage + t2 * total_n_glue_op * nblocking), total_n_glue_op * nblocking * 2, MPI_DOUBLE, 0, GLB_T + lcor->list[icor].t2, cart_comm);
---
>                     MPI_Isend((double *)(gb_storage + t2 * total_n_glue_op * nblocking), total_n_glue_op * nblocking * 2, MPI_DOUBLE, 0, lcor->list[icor].t2, cart_comm, req_1pt + lcor->list[icor].t2);
988c986,987
<                     MPI_Recv((double*)(gb2), total_n_glue_op * nblocking * 2, MPI_DOUBLE, t_to_proc[lcor->list[icor].t2], GLB_T + lcor->list[icor].t2, cart_comm, &r2);
---
>                 MPI_Irecv((double *)(gb2), total_n_glue_op * nblocking * 2, MPI_DOUBLE, t_to_proc[lcor->list[icor].t2], lcor->list[icor].t2, cart_comm, req_1pt + lcor->list[icor].t2);
>                 listsent[lcor->list[icor].t2] = 1;
990d988
<                 listsent[lcor->list[icor].t2] = 0;
992a991,995
>     if (PID == 0)
>         for (i = 0; i < GLB_T; i++)
>             if (listsent[i] == 1)
>             {
>                 MPI_Wait(req_1pt + i, MPI_STATUS_IGNORE);
993a997
> 
1130c1134
<   sign[a_]:=Module[{res},If[a>0,res="+",res="-"];res];
---
>   sign[ain_]:=Module[{res},If[ain>0,res="+",res="-"];res];
1156c1160
< void measure_1pt_glueballs(int nblocking, double *smear_val, double complex *gb_storage);
---
> void measure_1pt_glueballs(int nblockingstart, int nblockingend, double *smear_val, double complex *gb_storage);
** Make/Utils/write_mkflags.pl
28c28
<   'checkspinor!'   => \(my $scheck = 0),
---
>   'checkspinor!'   => \(my $scheck = 1),
38c38
<   'cflags=s'   => \(my $cflags = "-Wall -std=c99 -O3"),
---
>   'cflags=s'   => \(my $cflags = "-Wall -Wshadow -Wfatal-errors -Werror -std=c99 -O3"),
236c236
<   --cflags            [-O3]       Compilation options
---
>   --cflags            [-Wall -Wshadow -std=c99 -O3]       Compilation options
256c256
<   --[no-]checkspinor  [false]     Check spinor field type
---
>   --[no-]checkspinor  [true]      Check spinor field type
** Makefile
5c5
< EXCLUDEDIR := Analysis Doc Fortran HiRep.xcodeproj
---
> EXCLUDEDIR := Analysis Doc Fortran HiRep.xcodeproj Run
** ModeNumber/mk_eigvals.c
274,276c274
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** ModeNumber/mk_modenumber.c
266,268c266
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** PureGauge/Makefile
4c4
< EXES =  suN_multilevel suN
---
> EXES =  suN_multilevel suN suN_multilevel_measure
8c8
< suN_OBJS =  suN_utils.o
---
> suN_multilevel_measure_OBJS =  suN_utils_multilevel.o
9a10
> suN_OBJS =  suN_utils.o
12d12
< 
** PureGauge/input_file
2,6c2,6
< GLB_T = 32
< GLB_X = 8
< GLB_Y = 8
< GLB_Z = 8
< NP_T = 2
---
> GLB_T = 16
> GLB_X = 16
> GLB_Y = 16
> GLB_Z = 16
> NP_T = 4
22c22
< beta  =   6.0
---
> beta  =   6.1
24c24
< anisotropy  =   1.0
---
> anisotropy  =   2.464
34,40c34,38
< WF:tmax = 2.0
< //20
< WF:nmeas = 10
< //60
< WF:eps = 0.02
< WF:delta = 0.0001
< WF:anisotropy  = 1.0
---
> WF:tmax = 14.0
> WF:nmeas = 40
> WF:eps = 0.01
> WF:delta = 0.00001
> WF:anisotropy  = 3.0
45c43
< therm = 500
---
> therm = 50
** PureGauge/input_file_ml
2c2
< GLB_T = 32
---
> GLB_T = 16
6c6
< NP_T = 4
---
> NP_T = 2
22c22
< beta  =   6.0
---
> beta  =   6.1
33,36c33,36
< //The number of iterations per level must be written in a order string comma separated x1,x2,x3.... (one information per level)
< ML iterations per level = 0
< //The number of update skip per level must be writte n in a order string comma separated x1,x2,x3.... (one information per level) (each of these must be >=1)
< ML skip per level = 1 
---
> //The number of iterations per level must be written in a ordered string, comma separated x1,x2,x3.... (one information per level)
> ML iterations per level = 10
> //The number of update skip per level must be written in a ordered string, comma separated x1,x2,x3.... (one information per level) (each of these must be >=1)
> ML skip per level = 5 
39,40c39
< ML correlators = 10-12,9-12|10-13,9-13,8-13|9-14,8-14,7-14|8-15,7-15,6-15|7-16,6-16,4-18,3-18|4-19,3-19,2-19|3-20,2-20,1-20|2-21,1-21,0-21|1-22,0-22
< // ML correlators = 46-48,45-48|46-49,45-49,44-49|45-50,44-50,43-50|44-51,43-51,42-51|43-52,42-52,41-52|42-53,41-53,40-53|41-54,40-54,39-54|40-55,39-55,38-55|39-56,38-56,37-56|38-57,37-57,36-57|37-58,36-58,35-58|36-59,35-59,34-59|35-60,34-60,33-60|34-61,33-61,32-61|33-62,32-62,31-62|32-63,31-63,30-63|31-64,30-64,29-64|30-65,29-65,28-65|29-66,28-66,27-66|28-67,27-67,26-67|27-68,26-68,25-68|26-69,25-69,24-69|25-70,24-70|22-72,21-72|22-73,21-73,20-73|21-74,20-74,19-74|20-75,19-75,18-75|19-76,18-76,17-76|18-77,17-77,16-77|17-78
---
> ML correlators = 6-8,6-9|5-8,5-9
42c41
< nblk = 0
---
> nblk = 2
46c45
< wf:make = true
---
> WF:make = true
53a53
> WF:anisotropy = 1.0
59c59
< therm = 5000
---
> therm = 20
61c61
< save freq = 5000
---
> save freq = 1
68c68
< last conf = +200
---
> last conf = +20
** PureGauge/input_file_ml_measure
PureGauge/input_file_ml_measure not in both branches.
** PureGauge/suN.c
64c64
<     save_conf(&flow, MAX(int, 0, flow.start - 1));
---
>     save_conf(&flow, GENERIC_MAX(0, flow.start - 1));
95a96,98
>       static suNg_field *Vwf = NULL;
>       if (Vwf == NULL)
>         Vwf = alloc_gfield(&glattice);
97c100,101
<       WF_update_and_measure(flow.wf->ittype, u_gauge, &(flow.wf->tmax),
---
>       suNg_field_copy(Vwf, u_gauge);
>       WF_update_and_measure(flow.wf->ittype, Vwf, &(flow.wf->tmax),
126,128d129
< 
<   /* finalize Monte Carlo */
<   end_mc();
** PureGauge/suN_multilevel.c
65c65
<     save_conf(&flow, MAX(int, 0, flow.start - 1));
---
>     save_conf(&flow, GENERIC_MAX(0, flow.start - 1));
87,88c87,88
<         flow.pg_v->ml_niteration, flow.pg_v->ml_nskip, flow.pg_v->nblk,
<         &(flow.pg_v->APEsmear), &(flow.pg_v->corrs));
---
>         flow.pg_v->ml_niteration, flow.pg_v->ml_nskip, flow.pg_v->nblkstart,
>         flow.pg_v->nblkend, &(flow.pg_v->APEsmear), &(flow.pg_v->corrs));
97a98,100
>       static suNg_field *Vwf = NULL;
>       if (Vwf == NULL)
>         Vwf = alloc_gfield(&glattice);
99c102,103
<       WF_update_and_measure(RK3_ADAPTIVE, u_gauge, &(flow.wf->tmax),
---
>       suNg_field_copy(Vwf, u_gauge);
>       WF_update_and_measure(RK3_ADAPTIVE, Vwf, &(flow.wf->tmax),
139,141d142
< 
<   /* finalize Monte Carlo */
<   end_mc_ml();
** PureGauge/suN_multilevel_measure.c
PureGauge/suN_multilevel_measure.c not in both branches.
** PureGauge/suN_utils.c
211,213d210
< 
<   if (fabs(WF_var.anisotropy - 1) > 1.e-14) {
<     lprintf("INIT WF", 0, "WF anisotropy=%lf\n", WF_var.anisotropy);
215c212
<   }
---
>   lprintf("INIT WF", 0, "WF anisotropy=%lf\n", WF_var.anisotropy);
229,236d225
< 
<   return 0;
< }
< 
< int end_mc() {
<   WF_free();
< 
<   free_BCs();
** PureGauge/suN_utils.h
132d131
< int end_mc();
** PureGauge/suN_utils_multilevel.c
134,157c134
< int init_mc_ml(pg_flow_ml *gf, char *ifile) {
<   int start_t;
< 
<   strcpy(gf->g_start, "invalid");
<   strcpy(gf->run_name, "run_name");
<   strcpy(gf->last_conf, "invalid");
<   strcpy(gf->conf_dir, "./");
<   gf->save_freq = 0;
<   gf->therm = 0;
<   gf->pg_v = &pg_var_ml;
<   gf->wf = &WF_var;
<   gf->poly = &poly_var;
< 
<   read_input(pg_var_ml.read, ifile);
< 
<   lprintf("INIT ML", 0, "beta=%lf\n", pg_var_ml.beta);
<   lprintf("INIT ML", 0, "bare anisotropy=%lf\n", pg_var_ml.anisotropy);
<   lprintf("INIT ML", 0, "nhb=%d nor=%d\n", pg_var_ml.nhb, pg_var_ml.nor);
< 
<   set_max_mh_level(pg_var_ml.ml_levels);
< 
<   pg_var_ml.ml_niteration = malloc(sizeof(int) * pg_var_ml.ml_levels);
<   pg_var_ml.ml_nskip = malloc(sizeof(int) * pg_var_ml.ml_levels);
< 
---
> static void parse_ml_corellator_def() {
195,197d171
<   /*error(pg_var_ml.cml_corrs[0] == '\n', 1, "init_mc_ml " __FILE__, "At least
<    * one ML correpator must be defined");*/
< 
250c224
<                 pg_var_ml.corrs.list[j - 1 - l].t1 > GLB_T / 2,
---
>                 pg_var_ml.corrs.list[j - 1 - l].t1 >= GLB_T / 2 - 1,
253c227
<       error(pg_var_ml.corrs.list[j - 1 - l].t2 < GLB_T / 2 + 1 ||
---
>       error(pg_var_ml.corrs.list[j - 1 - l].t2 < GLB_T / 2 ||
286,287c260,290
<   lprintf("INIT ML", 0, "Blocking iteration on the observables=%d\n",
<           pg_var_ml.nblk);
---
> }
> 
> int init_mc_ml(pg_flow_ml *gf, char *ifile) {
>   int start_t;
> 
>   strcpy(gf->g_start, "invalid");
>   strcpy(gf->run_name, "run_name");
>   strcpy(gf->last_conf, "invalid");
>   strcpy(gf->conf_dir, "./");
>   gf->save_freq = 0;
>   gf->therm = 0;
>   gf->pg_v = &pg_var_ml;
>   gf->wf = &WF_var;
>   gf->poly = &poly_var;
> 
>   read_input(pg_var_ml.read, ifile);
> 
>   lprintf("INIT ML", 0, "beta=%lf\n", pg_var_ml.beta);
>   lprintf("INIT ML", 0, "bare anisotropy=%lf\n", pg_var_ml.anisotropy);
>   lprintf("INIT ML", 0, "nhb=%d nor=%d\n", pg_var_ml.nhb, pg_var_ml.nor);
> 
>   set_max_mh_level(pg_var_ml.ml_levels);
> 
>   pg_var_ml.ml_niteration = malloc(sizeof(int) * pg_var_ml.ml_levels);
>   pg_var_ml.ml_nskip = malloc(sizeof(int) * pg_var_ml.ml_levels);
> 
>   parse_ml_corellator_def();
> 
>   lprintf("INIT ML", 0,
>           "Blocking iteration on the observables (start/end)=(%d/%d)\n",
>           pg_var_ml.nblkstart, pg_var_ml.nblkend);
340a344,352
>   lprintf("INIT WF", 0, "WF make=%s\n", WF_var.make);
>   lprintf("INIT WF", 0, "WF max integration time=%lf\n", WF_var.tmax);
>   lprintf("INIT WF", 0, "WF number of measures=%d\n", WF_var.nmeas);
>   lprintf("INIT WF", 0, "WF initial epsilon=%lf\n", WF_var.eps);
>   lprintf("INIT WF", 0, "WF delta=%lf\n", WF_var.delta);
>   lprintf("INIT WF", 0, "WF anisotropy=%lf\n", WF_var.anisotropy);
> 
>   WF_set_bare_anisotropy(&(WF_var.anisotropy));
> 
341a354,382
>   lprintf("INIT WF", 0, "Polyakov make=%s\n", poly_var.make);
> 
>   return 0;
> }
> 
> int init_mc_ml_measure(pg_flow_ml_measure *gf, char *ifile) {
>   gf->pg_v = &pg_var_ml;
>   gf->wf = &WF_var;
>   gf->poly = &poly_var;
> 
>   read_input(pg_var_ml.read, ifile);
> 
>   lprintf("INIT ML", 0, "beta=%lf\n", pg_var_ml.beta);
>   lprintf("INIT ML", 0, "bare anisotropy=%lf\n", pg_var_ml.anisotropy);
>   lprintf("INIT ML", 0, "nhb=%d nor=%d\n", pg_var_ml.nhb, pg_var_ml.nor);
> 
>   set_max_mh_level(pg_var_ml.ml_levels);
> 
>   pg_var_ml.ml_niteration = malloc(sizeof(int) * pg_var_ml.ml_levels);
>   pg_var_ml.ml_nskip = malloc(sizeof(int) * pg_var_ml.ml_levels);
> 
>   parse_ml_corellator_def();
> 
>   lprintf("INIT ML", 0,
>           "Blocking iteration on the observables (start/end)=(%d/%d)\n",
>           pg_var_ml.nblkstart, pg_var_ml.nblkend);
>   lprintf("INIT ML", 0, "Ape smearing par=%lf\n", pg_var_ml.APEsmear);
> 
>   read_input(gf->read, ifile);
342a384,402
>   /* glueballs 1pt group structure */
>   report_op_group_setup();
> 
>   BCs_pars_t BCs_pars = {.fermion_twisting_theta = {0., 0., 0., 0.},
>                          .gauge_boundary_improvement_cs = 1.,
>                          .gauge_boundary_improvement_ct = 1.,
>                          .chiSF_boundary_improvement_ds = 1.,
>                          .SF_BCs = 0};
>   init_BCs(&BCs_pars);
> 
>   init_pure_gauge_anisotropy(&(pg_var_ml.anisotropy));
> 
>   WF_var.anisotropy = 1.0;
> 
>   read_input(WF_var.read, ifile);
> 
>   WF_initialize();
> 
>   lprintf("INIT WF", 0, "WF make=%s\n", WF_var.make);
347,348d406
< 
<   if (fabs(WF_var.anisotropy - 1) > 1.e-14) {
349a408
> 
351c410,412
<   }
---
> 
>   read_input(poly_var.read, ifile);
>   lprintf("INIT WF", 0, "Polyakov make=%s\n", poly_var.make);
365,372d425
< 
<   return 0;
< }
< 
< int end_mc_ml() {
<   WF_free();
< 
<   free_BCs();
** PureGauge/suN_utils_multilevel.h
22c22
<   int nhb, nor, ml_levels, nblk;
---
>   int nhb, nor, ml_levels, nblkstart, nblkend;
32c32
<   input_record_t read[11];
---
>   input_record_t read[12];
51,52c51,54
<       {"nnumber of spatial blocking level to generate lueballs", "nblk = %d",  \
<        INT_T, &((varname).nblk)},                                              \
---
>       {"start index of spatial blocking level to measure glueballs",           \
>        "nblkstart = %d", INT_T, &((varname).nblkstart)},                       \
>       {"end index of spatial blocking level to measure glueballs",             \
>        "nblkend = %d", INT_T, &((varname).nblkend)},                           \
145a148,170
> typedef struct _pg_flow_ml_measure {
>   char configlist[256]; /* directory to store gconfs */
> 
>   input_pg_ml *pg_v;
> 
>   input_WF *wf;
> 
>   input_poly *poly;
> 
>   /* for the reading function */
>   input_record_t read[2];
> 
> } pg_flow_ml_measure;
> 
> #define init_pg_flow_ml_measure(varname)                                       \
>   {                                                                            \
>     .read = {                                                                  \
>       {"Configuration list", "configlist = %s", STRING_T,                      \
>        &(varname).configlist},                                                 \
>       {NULL, NULL, INT_T, NULL}                                                \
>     }                                                                          \
>   }
> 
146a172
> int init_mc_ml_measure(pg_flow_ml_measure *rf, char *ifile);
148d173
< int end_mc_ml();
** Reweight/reweight.c
236c236
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Scattering/scatter.c
** Spectrum/measure_formfactor.c
9a10
> #include "clover_tools.h"
255c256
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
344c345
<                             mes_var.precision);
---
>                             mes_var.precision, DONTSTORE, NULL);
348c349,350
<                                mes_var.n_mom, i, mes_var.precision);
---
>                                mes_var.n_mom, i, mes_var.precision, DONTSTORE,
>                                NULL);
** Spectrum/measure_spectrum.c
11a12
> #include "data_storage.h"
318c319
<                                          mes_var.nEz);
---
>                                          mes_var.nEz, DONTSTORE, NULL);
330,331c331,332
<         measure_spectrum_semwall(nm, m, mes_var.nhits_2pt, i,
<                                  mes_var.precision);
---
>         measure_spectrum_semwall(nm, m, mes_var.nhits_2pt, i, mes_var.precision,
>                                  DONTSTORE, NULL);
334c335,336
<         measure_spectrum_pt(tau, nm, m, mes_var.n_mom, i, mes_var.precision);
---
>         measure_spectrum_pt(tau, nm, m, mes_var.n_mom, i, mes_var.precision,
>                             DONTSTORE, NULL);
338c340
<         measure_baryons(m, i, mes_var.precision);
---
>         measure_baryons(m, i, mes_var.precision, DONTSTORE, NULL);
348c350,351
<         //       measure_spectrum_gfwall(nm,m,i,mes_var.precision);
---
>         //       measure_spectrum_gfwall(nm,m,i,mes_var.precision,DONTSTORE,
>         //       NULL);
352c355
<                                      mes_var.precision);
---
>                                      mes_var.precision, DONTSTORE, NULL);
355,356c358,359
<         measure_spectrum_pt_ext(tau, nm, m, mes_var.n_mom, i,
<                                 mes_var.precision);
---
>         measure_spectrum_pt_ext(tau, nm, m, mes_var.n_mom, i, mes_var.precision,
>                                 DONTSTORE, NULL);
360c363
<                                          i, mes_var.precision);
---
>                                          i, mes_var.precision, DONTSTORE, NULL);
364c367
<                                     mes_var.precision);
---
>                                     mes_var.precision, DONTSTORE, NULL);
367c370,371
<         //       measure_spectrum_gfwall_fixedbc(mes_var.dt,nm,m,i,mes_var.precision);
---
>         //       measure_spectrum_gfwall_fixedbc(mes_var.dt,nm,m,i,mes_var.precision,DONTSTORE,
>         //       NULL);
371c375
<                                         mes_var.precision);
---
>                                         mes_var.precision, DONTSTORE, NULL);
374c378,379
<         //       measure_spectrum_discon_gfwall(nm,m,i,mes_var.precision);
---
>         //       measure_spectrum_discon_gfwall(nm,m,i,mes_var.precision,DONTSTORE,
>         //       NULL);
378c383
<                                        mes_var.dilution);
---
>                                        mes_var.dilution, DONTSTORE, NULL);
384c389
<                                     mes_var.precision);
---
>                                     mes_var.precision, DONTSTORE, NULL);
387c392,393
<         measure_spectrum_ff_pt(tau, nm, m, mes_var.n_mom, i, mes_var.precision);
---
>         measure_spectrum_ff_pt(tau, nm, m, mes_var.n_mom, i, mes_var.precision,
>                                DONTSTORE, NULL);
391c397
<                                         mes_var.precision);
---
>                                         mes_var.precision, DONTSTORE, NULL);
396c402
<             mes_var.nhits_hopping, i, mes_var.precision);
---
>             mes_var.nhits_hopping, i, mes_var.precision, DONTSTORE, NULL);
** Spectrum/mk_mesons.c
326c326
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/mk_mesons_with_z2semwall.c
238c238
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/mk_mesons_with_z2semwall_new.c
238c238
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/random_cnfg.c
85c85
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/random_spinor.c
87c87
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/trunc_mesons.c
253c253
<   rlxd_init(glb_var.rlxd_level, glb_var.rlxd_seed + PID);
---
>   rlxd_init(glb_var.rlxd_level, glb_var.rlxd_seed);
** StaticPotential/tune_HYP_smearing.c
223,225c223
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/Deflate/check_deflate.c
271,282d270
<   /*read_input(rlx_var.read,input_filename);
<   lprintf("MAIN",0,"RLXD [%d,%d]\n",rlx_var.rlxd_level,rlx_var.rlxd_seed);
<   rlxd_init(rlx_var.rlxd_level,rlx_var.rlxd_seed+MPI_PID);
<   srand(rlx_var.rlxd_seed+MPI_PID);
< 
< #ifdef GAUGE_SON
<   lprintf("MAIN",0,"Gauge group: SO(%d)\n",NG);
< #else
<   lprintf("MAIN",0,"Gauge group: SU(%d)\n",NG);
< #endif
<   lprintf("MAIN",0,"Fermion representation: " REPR_NAME " [dim=%d]\n",NF);
< */
** TestProgram/DiracOperator/speed_test_diracoperator.c
27,33d26
< static double hmass = 0.1;
< static suNg_field *g;
< 
< // static void loc_D(spinor_field *out, spinor_field *in){
< //    Dphi(hmass,out,in);
< // }
< 
36,37c29,30
<   double res1, res2, res3, res_cpu, res_gpu;
<   spinor_field *s0, *s1, *s2, *s3, *tmps;
---
>   double res1, res2, res3;
>   spinor_field *s0, *s1, *s2;
40c33
<   int n_times = 5000;
---
>   int n_times = 50000;
52c45
<   s0 = alloc_spinor_field_f(4, &glattice);
---
>   s0 = alloc_spinor_field_f(3, &glattice);
55d47
<   s3 = s2 + 1;
60d51
<   lprintf("LA_TEST", 0, "un sito %lf\n", creal(s0->ptr[2].c[0].c[0]));
64,65c55
< #pragma omp parallel
<   {
---
>   _OMP_PRAGMA(_omp_parallel num_threads(1)) {
71a62
> 
100,102c91
< 
< #pragma omp parallel default(shared)
<   {
---
>   _OMP_PRAGMA(_omp_parallel) {
104c93
<       Dphi_(s1, s0);
---
>       Dphi_fused_(s1, s0);
107d95
< 
110d97
< 
112,113c99
< #pragma omp parallel default(shared)
<   {
---
>   _OMP_PRAGMA(_omp_parallel) {
115c101
<       Dphi_(s1, s0);
---
>       Dphi_fused_(s1, s0);
124,125d109
< #pragma omp parallel num_threads(1) default(shared)
<   {
130d113
< #pragma omp barrier
133d115
< #pragma omp barrier
136c118
<   }
---
> 
** TestProgram/DiracOperator/speed_test_diracoperator_flt.c
18a19
> #include "setup.h"
68,70c69
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
** TestProgram/Disconnected/Makefile
4,5c4
< TESTS = check_disc_0 check_disc_2 check_disc_3 check_disc_4 check_disc_5 
< FAIL = check_disc_1
---
> TESTS = check_disc_0 check_disc_1 check_disc_2 check_disc_3 check_disc_4 check_disc_5 
** TestProgram/Disconnected/check_disc_0.c
15a16
> #include "data_storage.h"
206c207
<   double complex ***out_corr;
---
>   data_storage_array *out_corr = NULL;
209c210
<   double abs_tol = 2e-1;
---
>   double abs_tol = 3e-1;
289,296d289
<   out_corr = (double complex ***)malloc(sizeof(double complex **) * n_mom_tot);
< 
<   for (int i = 0; i < n_mom_tot; i++)
<     out_corr[i] = (double complex **)malloc(sizeof(double complex *) * n_Gamma);
<   for (int i = 0; i < n_mom_tot; i++)
<     for (int j = 0; j < n_Gamma; j++)
<       out_corr[i][j] = (double complex *)calloc(GLB_T, sizeof(double complex));
< 
298,299c291,292
<   for (int i = 0; i < n_mom_tot; i++)
<     ex_loops[i] = (double complex *)calloc(n_Gamma, sizeof(double complex));
---
>   for (int l = 0; l < n_mom_tot; l++)
>     ex_loops[l] = (double complex *)calloc(n_Gamma, sizeof(double complex));
300a294
>   // stochastic & time average
302,303c296,297
<   for (int i = 0; i < n_mom_tot; i++)
<     mean_loops[i] = (double complex *)calloc(n_Gamma, sizeof(double complex));
---
>   for (int l = 0; l < n_mom_tot; l++)
>     mean_loops[l] = (double complex *)calloc(n_Gamma, sizeof(double complex));
305,306c299,300
<   measure_loops(1, &mass, nhits, 0, mes_ip.precision, source_type, mes_ip.n_mom,
<                 out_corr);
---
>   measure_loops(&mass, nhits, 0, mes_ip.precision, source_type, mes_ip.n_mom,
>                 STORE, &out_corr);
308,309c302,303
<   // stochastic & time average
<   for (int i = 0; i < n_mom_tot; i++)
---
>   for (int k = 0; k < nhits; k++)
>     for (int l = 0; l < n_mom_tot; l++)
311,313c305,312
<       for (int t = 0; t < GLB_T; t++)
<         mean_loops[i][j] += out_corr[i][j][t] / (nhits * GLB_T);
< 
---
>         for (int t = 0; t < GLB_T; t++) {
>           int idx_re[5] = {k, l, j, t, 0};
>           int idx_im[5] = {k, l, j, t, 1};
> 
>           mean_loops[l][j] += (*data_storage_element(out_corr, 0, idx_re) +
>                                I * *data_storage_element(out_corr, 0, idx_im)) /
>                               (nhits * GLB_T);
>         }
** TestProgram/Disconnected/check_disc_1.c
16a17
> #include "data_storage.h"
148,207d148
< /* Ugly: read the correlator from the output files ! This is because the
< function that compute the props, make the contractions and write the output
< zeros the correlators after writting them.
< The purpose of this entire test is to check the function without modifying it */
< static double complex read_and_average_output_disc(int t, int ixG, int nhits) {
<   char char_t[100];
<   char char_ixG[100];
<   char char_isrc[100];
<   FILE *fp;
<   char path[1035];
<   char command[500];
<   char command_re[500];
<   char command_im[500];
<   double tmp_re, tmp_im;
<   double complex out;
<   int i;
< 
<   sprintf(char_t, "%d", t);
<   sprintf(char_ixG, "%d", ixG);
<   _complex_0(out);
< 
<   for (i = 0; i < nhits; i++) {
< 
<     strcpy(command, "grep \'\\[CORR\\]\\[0\\]");
<     strcat(command, char_t);
<     strcat(command, " ");
<     strcat(command, char_ixG);
< 
<     sprintf(char_isrc, "%d", i);
<     strcat(command, " ");
<     strcat(command, char_isrc);
<     strcat(command, " \'");
< 
<     strcpy(command_re, command);
<     strcpy(command_im, command);
< 
<     strcat(command_re, " out_0 | awk  '{print $4}' ");
<     strcat(command_im, " out_0 | awk  '{print $5}' ");
< 
<     fp = popen(command_re, "r");
<     while (fgets(path, sizeof(path) - 1, fp) != NULL) {
<       // printf("%s", path);
<       sscanf(path, "%lf", &tmp_re);
<     }
<     /* close */
<     pclose(fp);
<     fp = popen(command_im, "r");
<     while (fgets(path, sizeof(path) - 1, fp) != NULL) {
<       // printf("%s", path);
<       sscanf(path, "%lf", &tmp_im);
<     }
<     /* close */
<     pclose(fp);
< 
<     out += tmp_re + I * tmp_im;
<   }
< 
<   return out / nhits;
< }
< 
235a177,215
> int compare_disc(double complex *corr_ex, double complex *corr_num,
>                  char *name[16], double tol, double tol_rel_scalar) {
>   int retval = 0;
>   int nGamma = 16;
>   for (int n = 0; n < nGamma; n++) {
>     if (n == 8) {
>       if (cabs(corr_ex[8] - corr_num[8]) / cabs(corr_ex[8]) > tol_rel_scalar) {
>         lprintf("TEST", 0,
>                 "Mismatch %s, rel diff: %e, numeric = %e + I*(%e), analytic = "
>                 "%e + I*(%e) \n",
>                 name[n], cabs(corr_ex[n] - corr_num[n]) / cabs(corr_ex[n]),
>                 creal(corr_num[n]), cimag(corr_num[n]), creal(corr_ex[n]),
>                 cimag(corr_ex[n]));
>         retval += 1;
>       } else {
>         lprintf("TEST", 0,
>                 "Match %s, numeric = %e + I*(%e), analytic = %e + I*(%e) \n",
>                 name[n], creal(corr_num[n]), cimag(corr_num[n]),
>                 creal(corr_ex[n]), cimag(corr_ex[n]));
>       }
>     } else {
>       if (cabs(corr_ex[n] - corr_num[n]) > tol) {
>         lprintf("TEST", 0,
>                 "Mismatch %s, absolute diff: %e, numeric = %e + I*(%e), "
>                 "analytic = %e + I*(%e) \n",
>                 name[n], cabs(corr_ex[n] - corr_num[n]), creal(corr_num[n]),
>                 cimag(corr_num[n]), creal(corr_ex[n]), cimag(corr_ex[n]));
>         retval += 1;
>       } else {
>         lprintf("TEST", 0,
>                 "Match %s, numeric = %e + I*(%e), analytic = %e + I*(%e) \n",
>                 name[n], creal(corr_num[n]), cimag(corr_num[n]),
>                 creal(corr_ex[n]), cimag(corr_ex[n]));
>       }
>     }
>   }
>   return retval;
> }
> 
237,240c217,220
<   int i, j, sign, n_mom_tot;
<   int n_Gamma = 16;
<   double complex ex_loops[16];
<   double complex ***out_corr;
---
>   int i, sign;
>   double complex *ex_loops;
>   data_storage_array *out_corr = NULL;
>   double complex *mean_loops;
243a224,227
>   int n_Gamma = 16;
>   double abs_tol = 1.5e-1;
>   double rel_tol_scalar_loop = 1e-2;
>   struct timeval start, end, etime;
308c292
<           "source type is fixed to 1:  Gauge fixed source  with time and spin "
---
>           "source type is fixed to 1:  Gauge fixed source  with time, spin  "
321,322c305,306
<   n_mom_tot = mes_ip.n_mom * mes_ip.n_mom * mes_ip.n_mom;
<   out_corr = (double complex ***)malloc(sizeof(double complex **) * n_mom_tot);
---
>   measure_loops(&mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
>                 mes_ip.n_mom, STORE, &out_corr);
324,326c308,310
<   for (int i = 0; i < n_mom_tot; i++)
<     out_corr[i] = (double complex **)malloc(sizeof(double complex *) * n_Gamma);
<   for (int i = 0; i < n_mom_tot; i++)
---
>   mean_loops = (double complex *)calloc(n_Gamma, sizeof(double complex));
>   for (int k = 0; k < mes_ip.nhits; k++)
>     for (int l = 0; l < NF; l++)
328,338c312,319
<       out_corr[i][j] = (double complex *)calloc(GLB_T, sizeof(double complex));
< 
<   measure_loops(1, &mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
<                 mes_ip.n_mom, out_corr);
< 
<   double complex loops[16];
< 
<   for (i = 0; i < 16; i++) {
<     _complex_0(loops[i]);
<     for (j = 0; j < GLB_T; j++) { // average over time.
<       loops[i] += read_and_average_output_disc(j, i, mes_ip.nhits) / GLB_T;
---
>         for (int t = 0; t < GLB_T; t++) {
>           int idx_re[5] = {k, l, j, t, 0};
>           int idx_im[5] = {k, l, j, t, 1};
>           // VD: where does the factor 2 comes from ?
>           mean_loops[j] += (double)GLB_VOL3 *
>                            (*data_storage_element(out_corr, 0, idx_re) +
>                             I * *data_storage_element(out_corr, 0, idx_im)) /
>                            (2 * mes_ip.nhits * GLB_T);
340,341d320
<   }
< 
342a322
>   ex_loops = (double complex *)calloc(16, sizeof(double complex));
345,362c325,326
<   lprintf("TEST", 0, "\nAnalytical result\t Stochastic estimate\tERROR \n");
<   for (i = 0; i < 16; i++) {
<     lprintf("TEST", 0, "LOOPS %s\n", mes_channel_names[i]);
<     lprintf("TEST", 0, "%d %e+%e I \t%e+%e I \t%e+%e I \n", i,
<             creal(ex_loops[i]), cimag(ex_loops[i]), creal(loops[i]),
<             cimag(loops[i]), creal(ex_loops[i] - loops[i]),
<             cimag(ex_loops[i] - loops[i]));
<     if (cabs(loops[i]) <
<         1e-9) // most of loops are 0 by symmetry, in which case, the test makes
<               // sure that the both estimate have a norm below 1e-9
<     {
<       if (cabs(ex_loops[i]) > 1e-9)
<         return_value += 1;
<     } else if (cabs(ex_loops[i] - loops[i]) > 1e-1 * cabs(loops[i])) // if not
<     {
<       return_value += 1;
<     }
<   }
---
>   return_value += compare_disc(ex_loops, mean_loops, mes_channel_names, abs_tol,
>                                rel_tol_scalar_loop);
366a331,335
>   gettimeofday(&end, 0);
>   timeval_subtract(&etime, &end, &start);
>   lprintf("MAIN", 0, "Configuration : analysed in [%ld sec %ld usec]\n",
>           etime.tv_sec, etime.tv_usec);
> 
386a356
> 
389c359
<   int i, j;
---
>   int i;
414a385
> 
422,423c393,396
<           for (j = 0; j < 4; j++)
<             B[j] += sin((2.0 * M_PI * k[j]) / GLB_X) / tmp;
---
>           B[0] += sin((2.0 * M_PI * k[0]) / GLB_T) / tmp;
>           B[1] += sin((2.0 * M_PI * k[1]) / GLB_X) / tmp;
>           B[2] += sin((2.0 * M_PI * k[2]) / GLB_Y) / tmp;
>           B[3] += sin((2.0 * M_PI * k[3]) / GLB_Z) / tmp;
** TestProgram/Disconnected/check_disc_1.in
** TestProgram/Disconnected/check_disc_2.c
16a17
> #include "data_storage.h"
220d220
<   int n_mom_tot = 1;
223c223
<   double complex ***out_corr;
---
>   data_storage_array *out_corr = NULL;
225c225
<   double abs_tol = 1e-7;
---
>   double abs_tol = 5e-2;
305,315c305,306
< 
<   out_corr = (double complex ***)malloc(sizeof(double complex **) * n_mom_tot);
< 
<   for (int i = 0; i < n_mom_tot; i++)
<     out_corr[i] = (double complex **)malloc(sizeof(double complex *) * n_Gamma);
<   for (int i = 0; i < n_mom_tot; i++)
<     for (int j = 0; j < n_Gamma; j++)
<       out_corr[i][j] = (double complex *)calloc(GLB_T, sizeof(double complex));
< 
<   measure_loops(1, &mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
<                 mes_ip.n_mom, out_corr);
---
>   measure_loops(&mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
>                 mes_ip.n_mom, STORE, &out_corr);
318a310
>   for (int k = 0; k < mes_ip.nhits; k++)
320,321c312,319
<     for (int t = 0; t < GLB_T; t++)
<       mean_loops[j] += out_corr[0][j][t] / (mes_ip.nhits * GLB_T);
---
>       for (int t = 0; t < GLB_T; t++) {
>         int idx_re[4] = {k, j, t, 0};
>         int idx_im[4] = {k, j, t, 1};
> 
>         mean_loops[j] += (*data_storage_element(out_corr, 0, idx_re) +
>                           I * *data_storage_element(out_corr, 0, idx_im)) /
>                          (mes_ip.nhits * GLB_T);
>       }
** TestProgram/Disconnected/check_disc_2.in
20c20
< disc:nhits2 = 100
---
> disc:nhits2 = 200
** TestProgram/Disconnected/check_disc_3.c
16a17
> #include "data_storage.h"
220d220
<   int n_mom_tot = 1;
223c223
<   double complex ***out_corr;
---
>   data_storage_array *out_corr = NULL;
307,316c307,308
<   out_corr = (double complex ***)malloc(sizeof(double complex **) * n_mom_tot);
< 
<   for (int i = 0; i < n_mom_tot; i++)
<     out_corr[i] = (double complex **)malloc(sizeof(double complex *) * n_Gamma);
<   for (int i = 0; i < n_mom_tot; i++)
<     for (int j = 0; j < n_Gamma; j++)
<       out_corr[i][j] = (double complex *)calloc(GLB_T, sizeof(double complex));
< 
<   measure_loops(1, &mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
<                 mes_ip.n_mom, out_corr);
---
>   measure_loops(&mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
>                 mes_ip.n_mom, STORE, &out_corr);
319a312,313
>   for (int k = 0; k < mes_ip.nhits; k++)
>     for (int l = 0; l < NF; l++)
321,322c315,322
<     for (int t = 0; t < GLB_T; t++)
<       mean_loops[j] += out_corr[0][j][t] / (mes_ip.nhits * GLB_T);
---
>         for (int t = 0; t < GLB_T; t++) {
>           int idx_re[5] = {k, l, j, t, 0};
>           int idx_im[5] = {k, l, j, t, 1};
> 
>           mean_loops[j] += (*data_storage_element(out_corr, 0, idx_re) +
>                             I * *data_storage_element(out_corr, 0, idx_im)) /
>                            (mes_ip.nhits * GLB_T);
>         }
** TestProgram/Disconnected/check_disc_4.c
15a16
> #include "data_storage.h"
218d218
<   int n_mom_tot = 1;
222c222
<   double complex ***out_corr;
---
>   data_storage_array *out_corr = NULL;
305d304
<   out_corr = (double complex ***)malloc(sizeof(double complex **) * n_mom_tot);
307,314c306,307
<   for (int i = 0; i < n_mom_tot; i++)
<     out_corr[i] = (double complex **)malloc(sizeof(double complex *) * n_Gamma);
<   for (int i = 0; i < n_mom_tot; i++)
<     for (int j = 0; j < n_Gamma; j++)
<       out_corr[i][j] = (double complex *)calloc(GLB_T, sizeof(double complex));
< 
<   measure_loops(1, &mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
<                 mes_ip.n_mom, out_corr);
---
>   measure_loops(&mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
>                 mes_ip.n_mom, STORE, &out_corr);
316d308
<   // stochastic & time average
317a310,312
>   for (int k = 0; k < mes_ip.nhits; k++)
>     for (int eo = 0; eo < 2; eo++)
>       for (int col = 0; col < NF; col++)
319,320c314,321
<     for (int t = 0; t < GLB_T; t++)
<       mean_loops[j] += out_corr[0][j][t] / (mes_ip.nhits * GLB_T);
---
>           for (int t = 0; t < GLB_T; t++) {
>             int idx_re[6] = {k, eo, col, j, t, 0};
>             int idx_im[6] = {k, eo, col, j, t, 1};
> 
>             mean_loops[j] += (*data_storage_element(out_corr, 0, idx_re) +
>                               I * *data_storage_element(out_corr, 0, idx_im)) /
>                              (mes_ip.nhits * GLB_T);
>           }
** TestProgram/Disconnected/check_disc_5.c
16a17
> #include "data_storage.h"
236d236
<   int n_mom_tot = 1;
239c239
<   double complex ***out_corr;
---
>   data_storage_array *out_corr = NULL;
323,332c323,324
<   out_corr = (double complex ***)malloc(sizeof(double complex **) * n_mom_tot);
< 
<   for (int i = 0; i < n_mom_tot; i++)
<     out_corr[i] = (double complex **)malloc(sizeof(double complex *) * n_Gamma);
<   for (int i = 0; i < n_mom_tot; i++)
<     for (int j = 0; j < n_Gamma; j++)
<       out_corr[i][j] = (double complex *)calloc(GLB_T, sizeof(double complex));
< 
<   measure_loops(1, &mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
<                 mes_ip.n_mom, out_corr);
---
>   measure_loops(&mass, mes_ip.nhits, 0, mes_ip.precision, source_type,
>                 mes_ip.n_mom, STORE, &out_corr);
336c328,330
< 
---
>   for (int k = 0; k < mes_ip.nhits; k++)
>     for (int eo = 0; eo < 2; eo++)
>       for (int col = 0; col < NF; col++)
338,339c332,341
<     for (int t = 0; t < GLB_T; t++)
<       mean_loops[j] += out_corr[0][j][t] / (mes_ip.nhits * GLB_T);
---
>           for (int t = 0; t < GLB_T; t++) {
>             int idx_re[6] = {k, eo, col, j, t, 0};
>             int idx_im[6] = {k, eo, col, j, t, 1};
> 
>             mean_loops[j] += (*data_storage_element(out_corr, 0, idx_re) +
>                               I * *data_storage_element(out_corr, 0, idx_im)) /
>                              (mes_ip.nhits * GLB_T);
>           }
>   // for(int j=0; j<n_Gamma; j++)   for(int t=0; t<GLB_T; t++) mean_loops[j] +=
>   // out_corr[0][j][t]/(mes_ip.nhits*GLB_T);
** TestProgram/GaugeFix/check_gaugefix.c
121d120
<   suNg_field *u_gauge = alloc_gfield(&glattice);
** TestProgram/Geometry/check_lattice.sh
50,56d49
< done
< 
< 
< #ntests=`expr ${#test[@]} / 14`
< 
< 
< for (( i=0; i<ntests; i++ )) ; do
68c61,64
< 
---
>    echo "//Logger levels (default = -1)">>test_input
>    echo "log:default = -1">>test_input
>    echo "log:inverter = -1">>test_input
>    echo "log:forcestat = 0">>test_input
75,80c71,76
< (( ${test[$((i*14+13))]} > 18 )) && continue;
< cat test_input
< 
<    mpirun -np  ${test[$((i*14+13))]} ./check_geometry_1 -i ./test_input
<    pippo=`echo $?`;
<    if [ "${pippo}" != "0" ] ; then exit ; fi
---
>    (( ${test[$((i*14+13))]} > 18 )) && ((i--)) && continue;
>    #cat test_input
>    export OMP_NUM_THREADS=1
>    rm -f out_0
>    mpirun-openmpi-gcc11 --mca shmem posix --oversubscribe -np ${test[$((i*14+13))]} ./check_geometry_1 -i ./test_input
>    if [ "$?" != "0" ] ; then exit ; fi
82c78
<    echo "Ok!"
---
>    echo $i"/$ntests : Ok!"
** TestProgram/Integrators/Makefile
TestProgram/Integrators/Makefile not in both branches.
** TestProgram/Integrators/check_integrator_1.c
TestProgram/Integrators/check_integrator_1.c not in both branches.
** TestProgram/Integrators/check_integrator_1.h
TestProgram/Integrators/check_integrator_1.h not in both branches.
** TestProgram/Integrators/check_integrator_1.in
TestProgram/Integrators/check_integrator_1.in not in both branches.
** TestProgram/Integrators/check_integrator_utils_1.c
TestProgram/Integrators/check_integrator_utils_1.c not in both branches.
** TestProgram/Inverters/check_inverters_2
TestProgram/Inverters/check_inverters_2 not in both branches.
** TestProgram/Inverters/check_inverters_3.c
81c81
<   lprintf("QMR TEST", 0, "Norma iniziale: %e\n", tau);
---
>   lprintf("QMR TEST", 0, "Initial Norm: %e\n", tau);
** TestProgram/Inverters/check_inverters_5.c
** TestProgram/Mesons/check_spinmatrix.c
134,139c134,139
<     suNf_spinor out[4];                                                        \
<     mult_mat_spinor(out[0], A, in[0]);                                         \
<     mult_mat_spinor(out[1], A, in[1]);                                         \
<     mult_mat_spinor(out[2], A, in[2]);                                         \
<     mult_mat_spinor(out[3], A, in[3]);                                         \
<     assign_spin_matrix(sm, out);                                               \
---
>     suNf_spinor _out[4];                                                       \
>     mult_mat_spinor(_out[0], A, in[0]);                                        \
>     mult_mat_spinor(_out[1], A, in[1]);                                        \
>     mult_mat_spinor(_out[2], A, in[2]);                                        \
>     mult_mat_spinor(_out[3], A, in[3]);                                        \
>     assign_spin_matrix(sm, _out);                                              \
** TestProgram/Mesons/check_triplets_1.c
199c199
<   double complex A[GLB_T], B[4][GLB_T];
---
>   double complex AA[GLB_T], BB[4][GLB_T];
232,236c232,236
<           A[t] = 0.;
<           B[0][t] = 0.;
<           B[1][t] = 0.;
<           B[2][t] = 0.;
<           B[3][t] = 0.;
---
>           AA[t] = 0.;
>           BB[0][t] = 0.;
>           BB[1][t] = 0.;
>           BB[2][t] = 0.;
>           BB[3][t] = 0.;
245,246c245,246
<             A[t] += creal(tmp) * eit / norm2;
<             B[0][t] += sin((2.0 * M_PI * k[0]) / GLB_T) * eit / norm2;
---
>             AA[t] += creal(tmp) * eit / norm2;
>             BB[0][t] += sin((2.0 * M_PI * k[0]) / GLB_T) * eit / norm2;
248c248
<               B[j][t] += sin((2.0 * M_PI * k[j]) / GLB_X) * eit / norm2;
---
>               BB[j][t] += sin((2.0 * M_PI * k[j]) / GLB_X) * eit / norm2;
252c252
<           A2[t] += A[t] * conj(A[t]) * z;
---
>           A2[t] += AA[t] * conj(AA[t]) * z;
254c254
<             B2[j][t] += B[j][t] * conj(B[j][t]) * z;
---
>             B2[j][t] += BB[j][t] * conj(BB[j][t]) * z;
** TestProgram/Mesons/check_triplets_3.c
16a17
> #include "data_storage.h"
37d37
< #include <stdio.h>
62a63
> 
110,121d110
< /*VD: This is kept to to some debugging.
<   static void print_mat(double complex mat[4][4], const char name[]) {
<     int i,j;
<     lprintf("MAIN",0,"%s = \n", name);
<     for(i=0; i<4; i++) {
<         lprintf("MAIN",0,"[ ");
<           for(j=0; j<4; j++) {
<             lprintf("MAIN",0,"(%.2f,%.2f) ",creal(mat[i][j]),cimag(mat[i][j]));
<           }
<           lprintf("MAIN",0,"]\n");
<         }
<       }*/
156,157c145,146
<   double complex g0[4][4];
<   g0_debug(g0, &sign);
---
>   double complex lg0[4][4];
>   g0_debug(lg0, &sign);
160,161c149,150
<   mult_mat(tmp2, g0, tmp);
<   mult_mat(Gammabar, tmp2, g0);
---
>   mult_mat(tmp2, lg0, tmp);
>   mult_mat(Gammabar, tmp2, lg0);
166,207d154
< char char_t[100];
< FILE *fp;
< char path[1035];
< 
< /* Ugly: read the correlator from the output files ! This is because the
< function that compute the props, make the contractions and write the output
< zeros the correlators after writting them.
< The purpose of this entire test is to check the function without modifying it */
< static double read_output(int t, int i, int re_im_flag) {
<   char char_t[100];
<   FILE *fp;
<   char path[1035];
<   char command[500];
<   double out;
< 
<   sprintf(char_t, "%d", t + 1);
<   strcpy(command, "grep \"TRIPLET ");
<   strcat(command, mes_channel_names[i]);
<   if (re_im_flag == 0) // get the real part.
<   {
<     strcat(command, "=\" out_0 | awk -F'=' '{print $3}' | awk '{for "
<                     "(i=1;i<=NF;i++) print $i}' | awk 'NR==");
<   }
<   if (re_im_flag == 1) {
<     strcat(command, "_im=\" out_0 | awk -F'=' '{print $3}' | awk  '{for "
<                     "(i=1;i<=NF;i++) print $i}' | awk 'NR==");
<   }
<   strcat(command, char_t);
<   strcat(command, "'");
< 
<   // printf("%d %d %s \n", i,t ,command);
<   fp = popen(command, "r");
<   while (fgets(path, sizeof(path) - 1, fp) != NULL) {
<     // printf("%s", path);
<     sscanf(path, "%lf", &out);
<   }
< 
<   /* close */
<   pclose(fp);
< 
<   return out;
< }
216c163
<   double complex g0[4][4], gmu[4][4];
---
>   double complex lg0[4][4], gmu[4][4];
218c165
<   g0_debug(g0, &sign);
---
>   g0_debug(lg0, &sign);
229,230c176,177
<   mult_mat(tmp2, g0, tmp);
<   mult_mat(Gammabar, tmp2, g0);
---
>   mult_mat(tmp2, lg0, tmp);
>   mult_mat(Gammabar, tmp2, lg0);
237d183
<   //  printf("get_g1 %d %f %f \n",i,creal(r)/4.,cimag(r)/4.);
247d192
<   // printf("get_g0 %f %f \n",creal(r)/4.,cimag(r)/4.);
249a195
> 
255a202
>   data_storage_array *out_corr = NULL;
275,278d221
<   char *mes_channel_names[16] = {
<       "g5",   "id",   "g0",   "g1",   "g2",   "g3",     "g0g1",   "g0g2",
<       "g0g3", "g0g5", "g5g1", "g5g2", "g5g3", "g0g5g1", "g0g5g2", "g0g5g3"};
< 
327,329c270
<   // int tau, int nm, double* m, int n_mom,int conf_num, double precision)
<   measure_spectrum_pt(0, 1, &mass, 1, 0, 1e-28);
< 
---
>   measure_spectrum_pt(0, 1, &mass, 1, 0, 1e-28, STORE, &out_corr);
336c277,280
<       corr_triplets[i][t] = read_output(t, i, 0) + I * read_output(t, i, 1);
---
>       int idx_re[5] = {0, 0, i, t, 0};
>       int idx_im[5] = {0, 0, i, t, 1};
>       corr_triplets[i][t] = (*data_storage_element(out_corr, 0, idx_re) +
>                              I * *data_storage_element(out_corr, 0, idx_im));
** TestProgram/Mesons/check_triplets_4.c
13a14
> #define _BSD_SOURCE
16a18
> #include "data_storage.h"
37d38
< #include <stdio.h>
66a68,70
> static double mass;
> void free_correlators(double **triplets);
> 
110,121d113
< /*VD: This is kept to to some debugging.
<   static void print_mat(double complex mat[4][4], const char name[]) {
<     int i,j;
<     lprintf("MAIN",0,"%s = \n", name);
<     for(i=0; i<4; i++) {
<         lprintf("MAIN",0,"[ ");
<           for(j=0; j<4; j++) {
<             lprintf("MAIN",0,"(%.2f,%.2f) ",creal(mat[i][j]),cimag(mat[i][j]));
<           }
<           lprintf("MAIN",0,"]\n");
<         }
<       }*/
144,146d135
< static double mass;
< void free_correlators(double **triplets);
< 
156,157c145,146
<   double complex g0[4][4];
<   g0_debug(g0, &sign);
---
>   double complex lg0[4][4];
>   g0_debug(lg0, &sign);
160,161c149,150
<   mult_mat(tmp2, g0, tmp);
<   mult_mat(Gammabar, tmp2, g0);
---
>   mult_mat(tmp2, lg0, tmp);
>   mult_mat(Gammabar, tmp2, lg0);
166,205d154
< char char_t[100];
< FILE *fp;
< char path[1035];
< 
< /* Ugly: read the correlator from the output files ! This is because the
< function that compute the props, make the contractions and write the output
< zeros the correlators after writting them.
< The purpose of this entire test is to check the function without modifying it */
< static double read_output(int t, int i, int re_im_flag) {
<   char char_t[100];
<   FILE *fp;
<   char path[1035];
<   char command[500];
<   double out;
< 
<   sprintf(char_t, "%d", t + 1);
<   strcpy(command, "grep \"TRIPLET ");
<   strcat(command, mes_channel_names[i]);
<   if (re_im_flag == 0) // get the real part.
<   {
<     strcat(command, "=\" out_0 | awk -F'=' '{print $3}' | awk '{for "
<                     "(i=1;i<=NF;i++) print $i}' | awk 'NR==");
<   }
<   if (re_im_flag == 1) {
<     strcat(command, "_im=\" out_0 | awk -F'=' '{print $3}' | awk  '{for "
<                     "(i=1;i<=NF;i++) print $i}' | awk 'NR==");
<   }
<   strcat(command, char_t);
<   strcat(command, "'");
< 
<   fp = popen(command, "r");
<   while (fgets(path, sizeof(path) - 1, fp) != NULL) {
<     sscanf(path, "%lf", &out);
<   }
< 
<   /* close */
<   pclose(fp);
< 
<   return out;
< }
214c163
<   double complex g0[4][4], gmu[4][4];
---
>   double complex lg0[4][4], gmu[4][4];
216c165
<   g0_debug(g0, &sign);
---
>   g0_debug(lg0, &sign);
227,228c176,177
<   mult_mat(tmp2, g0, tmp);
<   mult_mat(Gammabar, tmp2, g0);
---
>   mult_mat(tmp2, lg0, tmp);
>   mult_mat(Gammabar, tmp2, lg0);
252a202
>   data_storage_array *out_corr = NULL;
259c209
<   mult_mat(g[6], g[2], g[3]) // g0g1
---
>   mult_mat(g[6], g[2], g[3]); // g0g1
262c212
<   mult_mat(g[9], g[2], g[0]) // g0g5
---
>   mult_mat(g[9], g[2], g[0]); // g0g5
270,273d219
<   char *mes_channel_names[16] = {
<       "g5",   "id",   "g0",   "g1",   "g2",   "g3",     "g0g1",   "g0g2",
<       "g0g3", "g0g5", "g5g1", "g5g2", "g5g3", "g0g5g1", "g0g5g2", "g0g5g3"};
< 
322c268,269
<   measure_spectrum_semwall(1, &mass, mes_ip.nhits_2pt, 0, 1e-28);
---
>   measure_spectrum_semwall(1, &mass, mes_ip.nhits_2pt, 0, 1e-28, STORE,
>                            &out_corr);
328c275,278
<       corr_triplets[i][t] = read_output(t, i, 0) + I * read_output(t, i, 1);
---
>       int idx_re[4] = {0, i, t, 0};
>       int idx_im[4] = {0, i, t, 1};
>       corr_triplets[i][t] = (*data_storage_element(out_corr, 0, idx_re) +
>                              I * *data_storage_element(out_corr, 0, idx_im));
** TestProgram/Propagator/check_propagator.c
2d1
<  * NOCOMPILE= WITH_MPI
54d52
< typedef enum { semwall_src, point_src, gfwall_src } source_type_t;
67,258c65
< #define init_input_mesons(varname)                                             \
<   {                                                                            \
<     .read = {                                                                  \
<       {"quark quenched masses", "mes:masses = %s", STRING_T,                   \
<        (varname).mstring},                                                     \
<       {"inverter precision", "mes:precision = %lf", DOUBLE_T,                  \
<        &(varname).precision},                                                  \
<       {"t_initial", "mes:ti = %d", INT_T, &(varname).ti},                      \
<       {"t_final", "mes:tf = %d", INT_T, &(varname).tf},                        \
<       {"enable Dirichlet point", "mes:ff_dirichlet_point = %d", INT_T,         \
<        &(varname).ff_fixed_point},                                             \
<       {"Distance of t_initial from Dirichlet boundary",                        \
<        "mes:dirichlet_dt = %d", INT_T, &(varname).dt},                         \
<       {NULL, NULL, INT_T, NULL}                                                \
<     }                                                                          \
<   }
< 
< char cnfg_filename[256] = "run1_8x8x8x8nc2rFUNnf2b2.000000m0.940000n10";
< char list_filename[256] = "";
< char input_filename[256] = "input_file";
< char output_filename[256] = "mesons.out";
< enum { UNKNOWN_CNFG, DYNAMICAL_CNFG, QUENCHED_CNFG };
< 
< input_mesons mes_var = init_input_mesons(mes_var);
< 
< typedef struct {
<   char string[256];
<   int t, x, y, z;
<   int nc, nf;
<   double b, m;
<   int n;
<   int type;
< } filename_t;
< 
< int parse_cnfg_filename(char *filename, filename_t *fn) {
<   int hm;
<   char *tmp = NULL;
<   char *basename;
< 
<   basename = filename;
<   while ((tmp = strchr(basename, '/')) != NULL) {
<     basename = tmp + 1;
<   }
< 
< #ifdef REPR_FUNDAMENTAL
< #define repr_name "FUN"
< #elif defined REPR_SYMMETRIC
< #define repr_name "SYM"
< #elif defined REPR_ANTISYMMETRIC
< #define repr_name "ASY"
< #elif defined REPR_ADJOINT
< #define repr_name "ADJ"
< #endif
<   hm = sscanf(basename,
<               "%*[^_]_%dx%dx%dx%d%*[Nn]c%dr" repr_name "%*[Nn]f%db%lfm%lfn%d",
<               &(fn->t), &(fn->x), &(fn->y), &(fn->z), &(fn->nc), &(fn->nf),
<               &(fn->b), &(fn->m), &(fn->n));
<   if (hm == 9) {
<     fn->m = -fn->m; /* invert sign of mass */
<     fn->type = DYNAMICAL_CNFG;
<     return DYNAMICAL_CNFG;
<   }
< #undef repr_name
< 
<   double kappa;
<   hm = sscanf(basename, "%dx%dx%dx%d%*[Nn]c%d%*[Nn]f%db%lfk%lfn%d", &(fn->t),
<               &(fn->x), &(fn->y), &(fn->z), &(fn->nc), &(fn->nf), &(fn->b),
<               &kappa, &(fn->n));
<   if (hm == 9) {
<     fn->m = .5 / kappa - 4.;
<     fn->type = DYNAMICAL_CNFG;
<     return DYNAMICAL_CNFG;
<   }
< 
<   hm = sscanf(basename, "%dx%dx%dx%d%*[Nn]c%db%lfn%d", &(fn->t), &(fn->x),
<               &(fn->y), &(fn->z), &(fn->nc), &(fn->b), &(fn->n));
<   if (hm == 7) {
<     fn->type = QUENCHED_CNFG;
<     return QUENCHED_CNFG;
<   }
< 
<   hm = sscanf(basename, "%*[^_]_%dx%dx%dx%d%*[Nn]c%db%lfn%d", &(fn->t),
<               &(fn->x), &(fn->y), &(fn->z), &(fn->nc), &(fn->b), &(fn->n));
<   if (hm == 7) {
<     fn->type = QUENCHED_CNFG;
<     return QUENCHED_CNFG;
<   }
< 
<   fn->type = UNKNOWN_CNFG;
<   return UNKNOWN_CNFG;
< }
< 
< void read_cmdline(int argc, char *argv[]) {
<   int i, ai = 0, ao = 0, ac = 0, al = 0, am = 0;
<   FILE *list = NULL;
< 
<   for (i = 1; i < argc; i++) {
<     if (strcmp(argv[i], "-i") == 0)
<       ai = i + 1;
<     else if (strcmp(argv[i], "-o") == 0)
<       ao = i + 1;
<     else if (strcmp(argv[i], "-c") == 0)
<       ac = i + 1;
<     else if (strcmp(argv[i], "-l") == 0)
<       al = i + 1;
<     else if (strcmp(argv[i], "-m") == 0)
<       am = i;
<   }
< 
<   if (am != 0) {
<     print_compiling_info();
<     exit(0);
<   }
< 
<   if (ao != 0)
<     strcpy(output_filename, argv[ao]);
<   if (ai != 0)
<     strcpy(input_filename, argv[ai]);
< 
<   error((ac == 0 && al == 0) || (ac != 0 && al != 0), 1,
<         "parse_cmdline [mk_mesons.c]",
<         "Syntax: mk_mesons { -c <config file> | -l <list file> } [-i <input "
<         "file>] [-o <output file>] [-m]");
< 
<   if (ac != 0) {
<     strcpy(cnfg_filename, argv[ac]);
<     strcpy(list_filename, "");
<   } else if (al != 0) {
<     strcpy(list_filename, argv[al]);
<     error((list = fopen(list_filename, "r")) == NULL, 1,
<           "parse_cmdline [mk_mesons.c]", "Failed to open list file\n");
<     error(fscanf(list, "%s", cnfg_filename) == 0, 1,
<           "parse_cmdline [mk_mesons.c]", "Empty list file\n");
<     fclose(list);
<   }
< }
< 
< // Copied From meson_measurements
< static void fix_T_bc(int tau) {
<   int index;
<   int ix, iy, iz;
<   suNf *u;
<   if (--tau < 0)
<     tau += GLB_T;
<   lprintf("meson_measurements", 15,
<           "Setting Dirichlet boundary conidtion at global time slice %d, %d\n",
<           tau, T_BORDER);
<   if ((zerocoord[0] - 1 <= tau && zerocoord[0] + T > tau) ||
<       (zerocoord[0] == 0 && tau == GLB_T - 1)) {
<     for (ix = 0; ix < X_EXT; ++ix)
<       for (iy = 0; iy < Y_EXT; ++iy)
<         for (iz = 0; iz < Z_EXT; ++iz) {
<           if (((tau == zerocoord[0] - 1) ||
<                (zerocoord[0] == 0 && tau == GLB_T - 1)) &&
<               (NP_T > 1)) {
<             // printf("PID = %d, zc = %d, tau = %d\n", PID, zerocoord[0], tau);
<             index = ipt_ext(0, ix, iy, iz);
<           } else {
<             index = ipt_ext(T_BORDER + tau - zerocoord[0], ix, iy, iz);
<           }
<           if (index != -1) {
<             u = pu_gauge_f(index, 0);
<             _suNf_zero(*u);
<           }
<         }
<   }
<   lprintf("meson_measurements", 50, "Boundaries set!\n");
< }
< 
< // Why all the curly brackets? This is how mathematica likes to get matrices.
< static void print_prop(suNf_propagator S) {
<   int i, j;
<   lprintf("PROP", 10, "{");
<   for (i = 0; i < 4 * NF; i++) {
<     lprintf("PROP", 10, "{");
<     for (j = 0; j < 4 * NF; j++) {
<       if (j < 4 * NF - 1) {
<         lprintf("PROP", 10, "%.10f + I*%.10f, ", creal(_PROP_IDX(S, i, j)),
<                 cimag(_PROP_IDX(S, i, j)));
<       } else {
<         lprintf("PROP", 10, "%.10f + I*%.10f", creal(_PROP_IDX(S, i, j)),
<                 cimag(_PROP_IDX(S, i, j)));
<       }
<     }
<     if (i < 4 * NF - 1) {
<       lprintf("PROP", 10, "},");
<     } else {
<       lprintf("PROP", 10, "}");
<     }
<   }
<   lprintf("PROP", 10, "};\n");
< }
---
> input_mesons mes_var;
261,262c68
< static int check_g5herm(spinor_field *prop1, int t1, spinor_field *prop2,
<                         int t2) {
---
> static int check_g5herm(spinor_field *prop1, int t1, spinor_field *prop2) {
267,268c73,81
<   double complex tr;
<   lprintf("CK_G5HERM", 0, "Only Works in serial!\n");
---
>   double complex tr = 0.;
> #ifdef WITH_MPI
>   MPI_Status st;
> #endif
> 
>   int sender_rank = 0;
>   if (t1 > zerocoord[0] && t1 < zerocoord[0] + T && COORD[1] == 0 &&
>       COORD[2] == 0 && COORD[3] == 0) {
>     sender_rank = PID;
270c83,102
<   ix2 = ipt(t2 - zerocoord[0], 0, 0, 0);
---
>     for (a = 0; a < NF; ++a)
>       for (beta = 0; beta < 4; beta++)
>         _propagator_assign(sp1, *_FIELD_AT(&prop1[a * 4 + beta], ix1), a,
>                            beta); // S( (ti,0,0,0), (0,0,0,0) )
> #ifdef WITH_MPI
>     MPI_Send(&sp1, NF * 4 * 4 * sizeof(suNf_vector) / sizeof(double),
>              MPI_DOUBLE, 0, 999, GLB_COMM);
> #endif
>   }
> 
>   global_sum_int(&sender_rank, 1);
> 
>   if (COORD[0] == 0 && COORD[1] == 0 && COORD[2] == 0 && COORD[3] == 0) {
> #ifdef WITH_MPI
>     MPI_Recv(&sp1, NF * 4 * 4 * sizeof(suNf_vector) / sizeof(double),
>              MPI_DOUBLE, sender_rank, 999, GLB_COMM, &st);
> #endif
> 
>     ix2 = ipt(0, 0, 0, 0);
> 
273,274d104
<       _propagator_assign(sp1, *_FIELD_AT(&prop1[a * 4 + beta], ix1), a,
<                          beta); // S( (2,0,0,0), (0,0,0,0) )
276c106
<                          beta); // S( (0,0,0,0), (2,0,0,0) )
---
>                            beta); // S( (0,0,0,0), (ti,0,0) )
283c113
<   print_prop(sp1);
---
>     // print_prop(sp1);
285c115
<   print_prop(spdag);
---
>     // print_prop(spdag);
288c118
<   print_prop(sp2);
---
>     // print_prop(sp2);
292a123,124
>   }
> 
331,441d162
< // Check sequential Gamma Seq(0,0) = Gamma g5 S^dag(x,0) g5 g5 S(x,0)
< static int check_sequential_point(spinor_field *prop_1, spinor_field *prop_2,
<                                   spinor_field *prop_seq, int ti) {
< 
<   lprintf("CK_SEQ", 0, "Only Works in serial!\n");
<   int ix1 = ipt(0, 0, 0, 0);
<   int ix2 = ipt(ti, 0, 0, 0);
<   suNf_propagator sp1, sp2, sp3, sptmp1, sptmp2;
<   int a, beta;
<   double complex tr;
< 
<   for (a = 0; a < NF; ++a) {
<     for (beta = 0; beta < 4; beta++) {
<       _propagator_assign(
<           sp1, *_FIELD_AT(&prop_seq[a * 4 + beta], ix1), a,
<           beta); // S( (0,0,0,0), (2,0,0,0) ) g5 S( (2,0,0,0), (0,0,0,0) )
<       _propagator_assign(sp2, *_FIELD_AT(&prop_2[a * 4 + beta], ix1), a,
<                          beta); // S( (0,0,0,0), (2,0,0,0) )
<       _propagator_assign(sp3, *_FIELD_AT(&prop_1[a * 4 + beta], ix2), a,
<                          beta); // S( (2,0,0,0), (0,0,0,0) )
<     }
<   }
< 
<   _g5_propagator(sptmp1, sp3);
<   _propagator_mul(sptmp2, sp2, sptmp1);
< 
<   _propagator_trace(tr, sptmp2);
<   lprintf("CK_SEQ", 0, "S(0,x) g5 S(x,0) point = %g + I%g\n", creal(tr),
<           cimag(tr));
<   print_prop(sptmp2);
< 
<   _propagator_trace(tr, sp1);
<   lprintf("CK_SEQ", 0, "S(0,x) g5 S(x,0) seq   = %g + I%g\n", creal(tr),
<           cimag(tr));
<   print_prop(sp1);
< 
<   _propagator_sub(sptmp1, sp1, sptmp2);
<   _propagator_trace(tr, sptmp1);
<   lprintf("CK_SEQ", 0, "point - seq   = %g + I%g\n", creal(tr), cimag(tr));
<   print_prop(sptmp1);
< 
<   if (cabs(tr) > 1.e-14)
<     return 1;
<   else
<     return 0;
< }
< 
< static int check_sequential(spinor_field *prop_seq, spinor_field *prop_1,
<                             int tau, int tf) {
< 
<   lprintf("CK_SEQ", 0, "Only Works in serial!\n");
< 
<   double complex Corr[2][GLB_T];
<   int ix, t, x, y, z, a, beta, tc;
<   double complex tr;
<   suNf_propagator sp0, sp1, spdag, sptmp;
< 
<   int i;
<   for (i = 0; i < 2; i++) {
<     for (t = 0; t < GLB_T; t++) {
<       Corr[i][t] = 0;
<     }
<   }
< 
<   for (t = 0; t < T; t++) {
<     tc = (zerocoord[0] + t + GLB_T - tau) % GLB_T;
<     for (x = 0; x < X; x++)
<       for (y = 0; y < Y; y++)
<         for (z = 0; z < Z; z++) {
<           ix = ipt(t, x, y, z);
< 
<           for (a = 0; a < NF; ++a) {
<             for (beta = 0; beta < 4; beta++) {
<               _propagator_assign(sp0, *_FIELD_AT(&prop_seq[a * 4 + beta], ix),
<                                  a, beta);
<               _propagator_assign(sp1, *_FIELD_AT(&prop_1[a * 4 + beta], ix), a,
<                                  beta);
<             }
<           }
<           _propagator_dagger(spdag, sp1);
< 
<           // Pion
<           _propagator_mul(sptmp, sp1, spdag);
<           _propagator_trace(tr, sptmp);
<           Corr[0][tc] += tr;
< 
<           // g5 Seq(0,0)
<           if (t == 0 && x == 0 && y == 0 && z == 0) {
<             _g5_propagator(sptmp, sp0);
<             _propagator_trace(tr, sptmp);
<             Corr[1][tc] += creal(tr);
<           }
<         } // END SPATIAL LOOP
<   }       // END TIME LOOP
< 
<   lprintf("CORR", 0, "Pion: ");
<   for (t = 0; t < T; t++) {
<     lprintf("CORR", 0, "%g ", creal(Corr[0][t]) / (GLB_VOL3));
<   }
<   lprintf("CORR", 0, "\n");
<   lprintf("CORR", 0, "SeqPion: ");
<   for (t = 0; t < T; t++) {
<     lprintf("CORR", 0, "%g ", creal(Corr[1][t] / (GLB_VOL3)));
<   }
<   lprintf("CORR", 0, "\n");
< 
<   if (cabs(Corr[0][tf] - Corr[1][0]) > 1e-14)
<     return 1;
<   else
<     return 0;
< }
444c165
<   int i, k, tmp;
---
>   int k, tmp;
455,467d175
<   i = 0;
<   for (i = 0; i < 2; ++i) {
<     mes_var.precision = 1e-24;
< 
<     mes_var.ti = T / 4;
<     mes_var.tf = T / 2;
<     m[0] = -0.12;
< 
<     lprintf("MAIN", 0, "ti = %d\n", mes_var.ti);
<     lprintf("MAIN", 0, "tf = %d\n", mes_var.tf);
<     lprintf("MAIN", 0, "m = %f\n", m[0]);
<     mes_var.ff_fixed_point = 1;
<     lprintf("MAIN", 0, "Inverter precision = %e\n", mes_var.precision);
480a189,205
>   for (k = 0; k < 4 * NF; k++) {
>     spinor_field_zero_f(prop_1 + k);
>     spinor_field_zero_f(prop_2 + k);
>     spinor_field_zero_f(prop_seq + k);
>   }
> 
>   mes_var.precision = 1e-24;
>   mes_var.ti = GLB_T / 4;
>   mes_var.tf = 3 * GLB_T / 4;
>   m[0] = 20.12;
> 
>   lprintf("MAIN", 0, "ti = %d\n", mes_var.ti);
>   lprintf("MAIN", 0, "tf = %d\n", mes_var.tf);
>   lprintf("MAIN", 0, "m = %f\n", m[0]);
>   mes_var.ff_fixed_point = 1;
>   lprintf("MAIN", 0, "Inverter precision = %e\n", mes_var.precision);
> 
487,489d211
<     lprintf("TEST", 0, "<p> %1.6f\n", avr_plaquette());
< 
<     full_plaquette();
492,500d213
<     if (i == 1) {
<       lprintf("MAIN", 10, "Applying Dirichlet Boundaries\n");
<       fix_T_bc(mes_var.ti -
<                mes_var.dt); // Apply fixed boundaryconditions by zeroing links
<                             // at time slice tau to direction 0.
<     } else {
<       lprintf("MAIN", 10, "Default Boundaries\n");
<     }
< 
508,516c221
<     tmp = check_g5herm(prop_1, mes_var.ti, prop_2, 0);
<     return_value += tmp;
<     create_sequential_source_point(source_seq, mes_var.ti, prop_1);
<     calc_propagator(prop_seq, source_seq, 4 * NF);
<     tmp = check_sequential_point(prop_1, prop_2, prop_seq, mes_var.ti);
<     return_value += tmp;
<     create_sequential_source(source_seq, mes_var.tf, prop_1);
<     calc_propagator(prop_seq, source_seq, 4 * NF);
<     tmp = check_sequential(prop_seq, prop_1, 0, mes_var.tf);
---
>   tmp = check_g5herm(prop_1, mes_var.ti, prop_2);
517a223,230
>   //  create_sequential_source_point(source_seq, mes_var.ti, prop_1);
>   //  calc_propagator(prop_seq, source_seq, 4 * NF);
>   //  tmp = check_sequential_point(prop_1, prop_2, prop_seq, mes_var.ti);
>   //  return_value += tmp;
>   //  create_sequential_source(source_seq, mes_var.tf, prop_1);
>   //  calc_propagator(prop_seq, source_seq, 4 * NF);
>   //  tmp = check_sequential(prop_seq, prop_1, 0, mes_var.tf);
>   //  return_value += tmp;
520,528c233
<     if (i == 0)
<       lprintf("MAIN", 0,
<               "Random configuration without Dirichlet boundaries: analysed in "
<               "[%ld sec %ld usec]\n",
<               etime.tv_sec, etime.tv_usec);
<     else
<       lprintf("MAIN", 0,
<               "Random configuration with Dirichlet boundaries: analysed in "
<               "[%ld sec %ld usec]\n",
---
>   lprintf("MAIN", 0, "Random configuration analysed in [%ld sec %ld usec]\n",
537c242
<   }
---
> 
** TestProgram/PureGauge/check_puregauge_3.c
66,68c66
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/Random/Makefile
** TestProgram/Random/testlx.c
15c15,18
< 
---
> #define MAIN_PROGRAM
> #include "../Include/global.h"
> #include "../Include/hr_omp.h"
> #include "../Include/logger.h"
24c27
< int main(void) {
---
> int main(int argc, char *argv[]) {
25a29,48
>   MPI_PID = 0;
>   MPI_WORLD_SIZE = 1;
> #ifdef WITH_MPI
>   int mpiret;
>   mpiret = MPI_Init(&argc, &argv);
>   if (mpiret != MPI_SUCCESS) {
>     char mesg[MPI_MAX_ERROR_STRING];
>     int mesglen;
>     MPI_Error_string(mpiret, mesg, &mesglen);
>     printf("ERROR: %s\n", mesg);
>   }
> 
>   MPI_Comm_rank(MPI_COMM_WORLD, &MPI_PID);
>   MPI_Comm_size(MPI_COMM_WORLD, &MPI_WORLD_SIZE);
> #endif
> 
>   rlxs_init(0, 32767);
>   rlxd_init(1, 32767);
>   _OMP_PRAGMA(_omp_parallel) {
>     int local_return_value = 0;
31a55,58
>     int tid = 0;
> #ifdef _OPENMP
>     tid = omp_get_thread_num();
> #endif
38,40d64
<   rlxs_init(0, 32767);
<   rlxd_init(1, 32767);
< 
202c226,227
<     if (xsn[k] != (xs[k + 60] * sbase))
---
>       if (xsn[k] != (xs[k + 60] * sbase)) {
>         if (tid == 0 && MPI_PID == 0) {
205c230,235
< 
---
>       } else {
>         if (tid != 0 || MPI_PID != 0) {
>           test1 = 1;
>         }
>       }
>     }
207c237,241
<     if (xdn[k] != (xd[k + 39] * base))
---
>       if (xdn[k] != (xd[k + 39] * base)) {
>         if (tid == 0 && MPI_PID == 0)
>           test2 = 1;
>       } else {
>         if (tid != 0 || MPI_PID != 0)
209a244
>     }
216c251
<     return_value += 1;
---
>       local_return_value += 1;
224c259
<     return_value += 1;
---
>       local_return_value += 1;
264c299
<     return_value += 1;
---
>       local_return_value += 1;
272c307
<     return_value += 1;
---
>       local_return_value += 1;
296a332,339
> 
>     _OMP_PRAGMA(atomic)
>     return_value += local_return_value;
>   }
> #ifdef WITH_MPI
>   MPI_Finalize();
> #endif
> 
** TestProgram/RotatedSF/check_rotatedsf_1.c
124c124
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_10.c
65c65
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_2.c
106c106
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_3.c
63c63
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_4.c
64c64
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_5.c
69c69
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_6.c
68c68
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_7.c
50c50
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_8.c
65c65
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_9.c
70c70
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/Scattering/check_scattering_length_I0.c
** TestProgram/Scattering/check_scattering_length_I0.in
27c27
< I0:nhits = 100
---
> I0:nhits = 200
** TestProgram/Scattering/check_scattering_rhopipi.c
** TestProgram/Sources/Makefile
4c4
< TESTS = check_stoch_sources_1sf check_stoch_sources_4sf
---
> TESTS = check_stoch_sources_1_spinor_field check_stoch_sources_4_spinor_field
** TestProgram/Sources/check_stoch_sources_1sf.c
TestProgram/Sources/check_stoch_sources_1sf.c not in both branches.
** TestProgram/Sources/check_stoch_sources_1sf.in
TestProgram/Sources/check_stoch_sources_1sf.in not in both branches.
** TestProgram/Sources/check_stoch_sources_4_spinor_field.c
TestProgram/Sources/check_stoch_sources_4_spinor_field.c not in both branches.
** TestProgram/Sources/check_stoch_sources_4sf.c
TestProgram/Sources/check_stoch_sources_4sf.c not in both branches.
** TestProgram/Sources/check_stoch_sources_4sf.in
TestProgram/Sources/check_stoch_sources_4sf.in not in both branches.
** TestProgram/SpinorField/check_spinorfield_1.c
52c52
< static void rotate_ptr(int n, spinor_field *pkk[], double complex v[]) {
---
> static void rotate_ptr(int n, spinor_field *pkk[], double complex vl[]) {
70c70
<       double complex *z = &v[k];
---
>       double complex *z = &vl[k];
** TestProgram/Update/check_update_1.c
101,103d100
<   /* finalize Monte Carlo */
<   end_mc();
< 
** TestProgram/Update/check_update_2.c
73,74c73,74
<   spinor_field *X = alloc_spinor_field_f(1, &glattice);
<   spinor_field *Y = alloc_spinor_field_f(1, &glattice);
---
>   spinor_field *Xl = alloc_spinor_field_f(1, &glattice);
>   spinor_field *Yl = alloc_spinor_field_f(1, &glattice);
76,77c76,77
<   create_z2_volume_source(X);
<   create_z2_volume_source(Y);
---
>   create_z2_volume_source(Xl);
>   create_z2_volume_source(Yl);
80c80
<   force_clover_fermion_taylor(X, Y, 1.0);
---
>   force_clover_fermion_taylor(Xl, Yl, 1.0);
87c87
<   force_clover_fermion(X, Y, 1.0);
---
>   force_clover_fermion(Xl, Yl, 1.0);
112,119d111
< #endif
< 
<   /* finalize Monte Carlo */
<   end_mc();
< 
<   free_gfield(u_gauge);
< #ifndef REPR_FUNDAMENTAL
<   free_gfield_f(u_gauge_f);
** TestProgram/Utils/check_exp_WF.c
65c65
<     WF_Exp_Taylor(&exptest, &test);
---
>     suNg_Exp_Taylor(&exptest, &test);
68c68
<     WF_Exp(&exptest2, &test);
---
>     suNg_Exp(&exptest2, &test);
** TestProgram/run_tests.sh
26a27,33
> 
> if [ -f .test_failed ]
> then 
>   exit 1 ;
> else 
>   exit 0 ;
> fi
