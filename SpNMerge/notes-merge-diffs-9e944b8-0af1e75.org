* master (0af1e750fc7af0791ed4ca6484269713d64880d7) to 9e944b89e4f5f03652ea57223f24d16863f00851
** HMC/hmc.c
319,322c319
<   /* finalize Monte Carlo */
<   end_mc();
< 
<   /* close communications */
---
>   /* inalize Monte Carlo & close communications */
** HMC/hmc_forces.c
240,242c240
<     rlxd_init(rlx_var.rlxd_level,
<               rlx_var.rlxd_seed +
<                   MPI_PID); /* use unique MPI_PID to shift seeds */
---
>     rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
379,381d376
< 
<   /* finalize Monte Carlo */
<   end_mc();
** HMC/hmc_utils.c
351,367d350
< 
< /* clean up memory */
< int end_mc() {
<   free_ghmc();
<   free_BCs();
< 
<   /* free memory */
<   free_gfield(u_gauge);
< #ifdef ALLOCATE_REPR_GAUGE_FIELD
<   free_gfield_f(u_gauge_f);
< #endif
<   if (u_scalar != NULL) {
<     free_scalar_field(u_scalar);
<   }
< 
<   return 0;
< }
** HMC/hmc_utils.h
82d81
< int end_mc();
** Include/dirac.h
12a13
> void Dphi_fused_(spinor_field *out, spinor_field *in);
** Include/geometry.h
36a37,39
>   int *fuse_mask;
>   int fuse_gauge_size;
>   int fuse_inner_counter;
46a50
>   _OMP_PRAGMA(_omp_parallel)                                                   \
50a55
> //#define _SITE_FOR(type, ip, is) _SITE_FOR_RED(type, ip, is, , )
70a76,93
> 
> #define _FUSE_IDX(type, is) (type)->fuse_mask[_fuse_master_for_ip_##is]
> 
> #define _FUSE_FOR_RED(type, ip, is, redop1, redop2)                            \
>   _OMP_PRAGMA(_omp_parallel)                                                   \
>   _OMP_PRAGMA(_omp_for redop1 redop2)                                          \
>   for (int ip = 0; ip < type->fuse_gauge_size; ip++)
> 
> #define _FUSE_MASTER_FOR_RED(type, is, redop1, redop2)                         \
>   _FUSE_FOR_RED((type), _fuse_master_for_ip_##is, is, redop1, redop2)
> 
> #define _FUSE_MASTER_FOR(type, is) _FUSE_MASTER_FOR_RED(type, is, nowait, )
> #define _FUSE_MASTER_FOR_SUM(type, is, ...)                                    \
>   _FUSE_MASTER_FOR_RED(type, is, _omp_sum(__VA_ARGS__), )
> #define _FUSE_MASTER_FOR_MAX(type, is, ...)                                    \
>   _FUSE_MASTER_FOR_RED(type, is, _omp_max(__VA_ARGS__), )
> #define _FUSE_MASTER_FOR_MIN(type, is, ...)                                    \
>   _FUSE_MASTER_FOR_RED(type, is, _omp_min(__VA_ARGS__), )
** Include/global.h
62a63,68
> /*path blocking size*/
> GLB_VAR(int, PB_T, = 2);
> GLB_VAR(int, PB_X, = 2);
> GLB_VAR(int, PB_Y, = 2);
> GLB_VAR(int, PB_Z, = 2);
> 
** Include/glueballs.h
10,11c10,11
< void measure_1pt_glueballs(int nblocking, double *smear_val,
<                            double complex *gb_storage);
---
> void measure_1pt_glueballs(int nblockingstart, int nblockingend,
>                            double *smear_val, double complex *gb_storage);
** Include/memory.h
24c24
< #define ALIGN 5
---
> #define ALIGN 8
** Include/ranlux.h
** Include/update.h
26c26,27
<                                      int *ml_up, int *ml_skip, int nblocking,
---
>                                      int *ml_up, int *ml_skip,
>                                      int nblockingstart, int nblockingsend,
** LibHR/Geometry/communications.c
555c555
<           lprintf("MPI", 0, "Req [%d] Source [%d] Tag [%] ERROR: %s\n", k,
---
>           lprintf("MPI", 0, "Req [%d] Source [%d] Tag [%d] ERROR: %s\n", k,
** LibHR/Geometry/geometry_init.c
391a392,393
>   lprintf("GEOMETRY_INIT", 0, "Size of the bulk subblocking (%d,%d,%d,%d)\n",
>           PB_T, PB_X, PB_Y, PB_Z);
** LibHR/Geometry/geometry_mpi_eo.c
347a348,375
> void eval_fusemask(geometry_descriptor *lglat) {
>   int counter = 0;
>   for (int ip = 0; ip < lglat->local_master_pieces; ip++)
>     counter += lglat->master_end[ip] - lglat->master_start[ip] + 1;
> 
>   lglat->fuse_gauge_size = counter;
> 
>   lglat->fuse_mask =
>       malloc(counter * sizeof(int)); // allocating memory for local volume
> 
>   lglat->fuse_inner_counter = counter;
> 
>   counter = 0;
>   /* loop through PIECEs */
>   for (int ip = 0; ip < lglat->local_master_pieces; ip++) {
>     /* loop through SITEs in PIECEs */
>     for (int is = lglat->master_start[ip]; is <= lglat->master_end[ip]; is++) {
>       lglat->fuse_mask[counter] = is;
>       counter++;
>     }
> 
>     if (ip == lglat->inner_master_pieces) {
>       lglat->fuse_inner_counter =
>           (lglat)->master_start[ip] - (lglat)->master_shift;
>     }
>   }
> }
> 
409c437
< static void walk_on_lattice(int id_mask, int eotype, int level, int id_zone,
---
> void walk_on_lattice(int id_mask, int eotype, int level, int id_zone,
410a439,441
>   int evblock[4] = {PB_T, PB_X, PB_Y, PB_Z};
>   if (level != 4)
>     evblock[0] = evblock[1] = evblock[2] = evblock[3] = 1;
411a443
>   int bx0, bx1, bx2, bx3;
424a457,459
>   lprintf("GEOMETRY", REPORTLVL, "blocking of the pathsize (%d,%d,%d,%d) \n",
>           evblock[0], evblock[1], evblock[2], evblock[3]);
> 
427,441c462,496
<     for (x3 = bl_start[3];
<          block_cond(bl_start[3], bl_start[3] + bl_width[3], x3); x3 += incr[3])
<       for (x2 = bl_start[2];
<            block_cond(bl_start[2], bl_start[2] + bl_width[2], x2);
<            x2 += incr[2])
<         for (x1 = bl_start[1];
<              block_cond(bl_start[1], bl_start[1] + bl_width[1], x1);
<              x1 += incr[1])
<           for (x0 = bl_start[0];
<                block_cond(bl_start[0], bl_start[0] + bl_width[0], x0);
<                x0 += incr[0]) {
<             x[inv_mask[id_mask][0]] = x0;
<             x[inv_mask[id_mask][1]] = x1;
<             x[inv_mask[id_mask][2]] = x2;
<             x[inv_mask[id_mask][3]] = x3;
---
>     for (bx3 = bl_start[3];
>          block_cond(bl_start[3], bl_start[3] + bl_width[3], bx3);
>          bx3 += incr[3] * evblock[inv_mask[id_mask][3]])
>       for (bx2 = bl_start[2];
>            block_cond(bl_start[2], bl_start[2] + bl_width[2], bx2);
>            bx2 += incr[2] * evblock[inv_mask[id_mask][2]])
>         for (bx1 = bl_start[1];
>              block_cond(bl_start[1], bl_start[1] + bl_width[1], bx1);
>              bx1 += incr[1] * evblock[inv_mask[id_mask][1]])
>           for (bx0 = bl_start[0];
>                block_cond(bl_start[0], bl_start[0] + bl_width[0], bx0);
>                bx0 += incr[0] * evblock[inv_mask[id_mask][0]]) {
>             for (x3 = 0; (x3 < evblock[inv_mask[id_mask][3]]) &&
>                          block_cond(bl_start[3], bl_start[3] + bl_width[3],
>                                     bx3 + incr[3] * x3);
>                  x3++)
>               for (x2 = 0; (x2 < evblock[inv_mask[id_mask][2]]) &&
>                            block_cond(bl_start[2], bl_start[2] + bl_width[2],
>                                       bx2 + incr[2] * x2);
>                    x2++)
>                 for (x1 = 0; (x1 < evblock[inv_mask[id_mask][1]]) &&
>                              block_cond(bl_start[1], bl_start[1] + bl_width[1],
>                                         bx1 + incr[1] * x1);
>                      x1++)
>                   for (x0 = 0;
>                        (x0 < evblock[inv_mask[id_mask][0]]) &&
>                        block_cond(bl_start[0], bl_start[0] + bl_width[0],
>                                   bx0 + incr[0] * x0);
>                        x0++) {
> 
>                     x[inv_mask[id_mask][0]] = bx0 + incr[0] * x0;
>                     x[inv_mask[id_mask][1]] = bx1 + incr[1] * x1;
>                     x[inv_mask[id_mask][2]] = bx2 + incr[2] * x2;
>                     x[inv_mask[id_mask][3]] = bx3 + incr[3] * x3;
> 
443,444c498,499
<                 eotype == (x0 + x1 + x2 + x3 + T_BORDER + X_BORDER + Y_BORDER +
<                            Z_BORDER + PSIGN) %
---
>                         eotype == (x[0] + x[1] + x[2] + x[3] + T_BORDER +
>                                    X_BORDER + Y_BORDER + Z_BORDER + PSIGN) %
447,448c502,503
<                       "walk_on_lattice T[%d] X[%d] Y[%d] Z[%d] \n", x[0], x[1],
<                       x[2], x[3]);
---
>                               "walk_on_lattice T[%d] X[%d] Y[%d] Z[%d] \n",
>                               x[0], x[1], x[2], x[3]);
458c513,514
< 
---
>             lprintf("GEOMETRY", REPORTLVL, "subblock\n");
>           }
1675a1732,1733
> 
>     eval_fusemask(&glattice);
1694a1753,1754
> 
>     eval_fusemask(&glat_even);
1713a1774,1775
> 
>     eval_fusemask(&glat_odd);
** LibHR/Geometry/process_init.c
128c128,129
<   int required = MPI_THREAD_SINGLE;
---
>   int required = MPI_THREAD_FUNNELED;
> 
137a139,142
>   error(provided < MPI_THREAD_FUNNELED, 1, "setup_process " __FILE__,
>         "MPI inizialization failed, The threading support level is lesser than "
>         "that demanded.\n");
> 
222,224c227
<     rlxd_init(rlx_var.rlxd_level,
<               rlx_var.rlxd_seed +
<                   MPI_PID); /* use unique MPI_PID to shift seeds */
---
>     rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** LibHR/Geometry/test_geometry_mpi.c
1157,1178d1156
< /*
< typedef struct _geometry_descriptor {
<   int inner_master_pieces;
<   int local_master_pieces;
<   int total_spinor_master_pieces;
<   int total_gauge_master_pieces;
<   int *master_start, *master_end;
<   int master_shift;
<   int ncopies_spinor;
<   int ncopies_gauge;
<   int *copy_from, *copy_to, *copy_len;
<   int copy_odd_shift;
<   int nbuffers_spinor;
<   int nbuffers_gauge;
<   int *rbuf_len, *sbuf_len;
<   int *rbuf_from_proc, *rbuf_start;
<   int *sbuf_to_proc, *sbuf_start;
<   int gsize_spinor;
<   int gsize_gauge;
< } geometry_descriptor;
< */
< 
** LibHR/IO/read_action.c
600a601
>   int result;
619,622c620,625
<   content = malloc(fsz);
<   lines = malloc(fsz);
<   type = malloc(fsz);
<   fread(content, fsz, 1, fp);
---
>   content = malloc(sizeof(char) * (fsz + 256));
>   lines = malloc(sizeof(char) * (fsz));
>   type = malloc(sizeof(char) * (fsz));
>   result = fread(content, 1, fsz, fp);
>   check(result != fsz, "Reading error\n");
> 
** LibHR/Memory/amalloc.c
112,113c112,113
<   true_addr = malloc(size + shift);
<   new = malloc(sizeof(*first));
---
>   true_addr = (char *)malloc(size + shift);
>   new = (struct addr_t *)malloc(sizeof(*first));
** LibHR/Observables/glueballs.c
10,11c10,11
< void measure_1pt_glueballs(int nblocking, double *smear_val,
<                            double complex *gb_storage) {
---
> void measure_1pt_glueballs(int nblockingstart, int nblockingend,
>                            double *smear_val, double complex *gb_storage) {
18c18
<   for (i = 0; i < nblocking; i++) {
---
>   for (i = 0; i < nblockingstart; i++) {
26a27
>   }
27a29
>   for (i = 0; i < nblockingend - nblockingstart; i++) {
29d30
< 
32c33
<       point_gb += total_n_glue_op * nblocking;
---
>       point_gb += total_n_glue_op * (nblockingend - nblockingstart + 1);
33a35,49
> 
>     wrk1 = spatial_APE_smear_wrkspace(smear_val, wrk2);
> 
>     release_wrk_space(wrk2);
> 
>     wrk2 = single_level_spatial_blocking_wrkspace(wrk1);
> 
>     release_wrk_space(wrk1);
>   }
> 
>   point_gb = gb_storage + (nblockingend - nblockingstart) * total_n_glue_op;
> 
>   for (nt = 0; nt < n_active_slices; nt++) {
>     eval_all_glueball_ops(active_slices_list[nt], point_gb);
>     point_gb += total_n_glue_op * (nblockingend - nblockingstart + 1);
** LibHR/Random/ranlxd.c
43a44
> #include "global.h"
50a52,77
> static void local_error(int no) {
>   switch (no) {
>   case 1:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of luxury level (should be 1 or 2)\n");
>     break;
>   case 2:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
>     break;
>   case 3:
>     printf("Error in rlxd_get\n");
>     printf("Undefined state (ranlxd is not initialized\n");
>     break;
>   case 5:
>     printf("Error in rlxd_reset\n");
>     printf("Unexpected input data\n");
>     break;
>   case 6:
>     printf("Unitialized random seed\n");
>     break;
>   }
>   printf("Program aborted\n");
>   exit(0);
> }
> 
95,117d121
< static void error(int no) {
<   switch (no) {
<   case 1:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of luxury level (should be 1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxd_get\n");
<     printf("Undefined state (ranlxd is not initialized\n");
<     break;
<   case 5:
<     printf("Error in rlxd_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
191c195
<     error(1);
---
>     local_error(1);
193c197
<   i = seed;
---
>   i = seed + MPI_PID;
201c205
<     error(2);
---
>     local_error(2);
243c247
<     rlxd_init(1, 1);
---
>     local_error(6);
260c264
<     error(3);
---
>     local_error(3);
285c289
<     error(5);
---
>     local_error(5);
289c293
<       error(5);
---
>       local_error(5);
298c302
<     error(5);
---
>     local_error(5);
315c319
<     error(5);
---
>     local_error(5);
318a323,597
> #ifdef _OPENMP
> #include "hr_omp.h"
> 
> #define BASE 0x1000000
> #define MASK 0xffffff
> 
> typedef struct {
>   int c1, c2, c3, c4;
> } vec_t;
> 
> typedef struct {
>   vec_t c1, c2;
> } dble_vec_t;
> 
> typedef union {
>   dble_vec_t vec[12];
>   int num[96];
> } x_struct;
> 
> static int *init = NULL, *pr, *prm, *ir, *jr, *is, *is_old, **next;
> static double *one_bit;
> static vec_t *carry;
> static x_struct *x;
> 
> #define STEP(pi, pj, ltid)                                                     \
>   d = (*pj).c1.c1 - (*pi).c1.c1 - carry[ltid].c1;                              \
>   (*pi).c2.c1 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c1 = d & MASK;                                                      \
>   d = (*pj).c1.c2 - (*pi).c1.c2 - carry[ltid].c2;                              \
>   (*pi).c2.c2 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c2 = d & MASK;                                                      \
>   d = (*pj).c1.c3 - (*pi).c1.c3 - carry[ltid].c3;                              \
>   (*pi).c2.c3 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c3 = d & MASK;                                                      \
>   d = (*pj).c1.c4 - (*pi).c1.c4 - carry[ltid].c4;                              \
>   (*pi).c2.c4 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c4 = d & MASK;                                                      \
>   d = (*pj).c2.c1 - (*pi).c2.c1;                                               \
>   carry[ltid].c1 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c1 = d & MASK;                                                      \
>   d = (*pj).c2.c2 - (*pi).c2.c2;                                               \
>   carry[ltid].c2 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c2 = d & MASK;                                                      \
>   d = (*pj).c2.c3 - (*pi).c2.c3;                                               \
>   carry[ltid].c3 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c3 = d & MASK;                                                      \
>   d = (*pj).c2.c4 - (*pi).c2.c4;                                               \
>   carry[ltid].c4 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c4 = d & MASK
> 
> static void update(void) {
>   int k, kmax, d;
>   dble_vec_t *pmin, *pmax, *pi, *pj;
> 
>   int tid = omp_get_thread_num();
> 
>   kmax = pr[tid];
>   pmin = &(x[tid].vec[0]);
>   pmax = pmin + 12;
>   pi = &(x[tid].vec[ir[tid]]);
>   pj = &(x[tid].vec[jr[tid]]);
> 
>   for (k = 0; k < kmax; k++) {
>     STEP(pi, pj, tid);
> 
>     pi += 1;
>     pj += 1;
>     if (pi == pmax)
>       pi = pmin;
>     if (pj == pmax)
>       pj = pmin;
>   }
> 
>   ir[tid] += prm[tid];
>   jr[tid] += prm[tid];
>   if (ir[tid] >= 12)
>     ir[tid] -= 12;
>   if (jr[tid] >= 12)
>     jr[tid] -= 12;
>   is[tid] = 8 * ir[tid];
>   is_old[tid] = is[tid];
> }
> 
> static void define_constants(void) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   one_bit[tid] = ldexp(1.0, -24);
> 
>   for (k = 0; k < 96; k++) {
>     next[tid][k] = (k + 1) % 96;
>     if ((k % 4) == 3)
>       next[tid][k] = (k + 5) % 96;
>   }
> }
> 
> void rlxd_init(int level, int seed) {
>   _OMP_PRAGMA(_omp_parallel) {
>     int tid = omp_get_thread_num();
>     int nt = omp_get_num_threads();
>     _OMP_PRAGMA(single) {
> 
>       init = malloc(nt * sizeof(int));
>       pr = malloc(nt * sizeof(int));
>       prm = malloc(nt * sizeof(int));
>       ir = malloc(nt * sizeof(int));
>       jr = malloc(nt * sizeof(int));
>       is = malloc(nt * sizeof(int));
>       is_old = malloc(nt * sizeof(int));
>       next = malloc(nt * sizeof(int *));
> 
>       one_bit = malloc(nt * sizeof(double));
>       carry = malloc(nt * sizeof(vec_t));
>       x = malloc(nt * sizeof(x_struct));
>     }
>     next[tid] = malloc(96 * sizeof(int));
>     int i, k, l;
>     int ibit, jbit, xbit[31];
>     int ix, iy;
> 
>     if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24) ||
>         (DBL_MANT_DIG < 48))
>       local_error(0);
> 
>     define_constants();
> 
>     if (level == 1)
>       pr[tid] = 202;
>     else if (level == 2)
>       pr[tid] = 397;
>     else
>       local_error(1);
> 
>     i = seed + tid + nt * MPI_PID;
> 
>     for (k = 0; k < 31; k++) {
>       xbit[k] = i % 2;
>       i /= 2;
>     }
> 
>     if ((seed <= 0) || (i != 0))
>       local_error(2);
> 
>     ibit = 0;
>     jbit = 18;
> 
>     for (i = 0; i < 4; i++) {
>       for (k = 0; k < 24; k++) {
>         ix = 0;
> 
>         for (l = 0; l < 24; l++) {
>           iy = xbit[ibit];
>           ix = 2 * ix + iy;
> 
>           xbit[ibit] = (xbit[ibit] + xbit[jbit]) % 2;
>           ibit = (ibit + 1) % 31;
>           jbit = (jbit + 1) % 31;
>         }
> 
>         if ((k % 4) != i)
>           ix = 16777215 - ix;
> 
>         x[tid].num[4 * k + i] = ix;
>       }
>     }
> 
>     carry[tid].c1 = 0;
>     carry[tid].c2 = 0;
>     carry[tid].c3 = 0;
>     carry[tid].c4 = 0;
> 
>     ir[tid] = 0;
>     jr[tid] = 7;
>     is[tid] = 91;
>     is_old[tid] = 0;
>     prm[tid] = pr[tid] % 12;
>     init[tid] = 1;
>   }
> }
> 
> void ranlxd(double r[], int n) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init == NULL)
>     local_error(6);
> 
>   for (k = 0; k < n; k++) {
> 
>     is[tid] = next[tid][is[tid]];
> 
>     if (is[tid] == is_old[tid])
>       update();
>     r[k] = one_bit[tid] * ((double)(x[tid].num[is[tid] + 4]) +
>                            one_bit[tid] * (double)(x[tid].num[is[tid]]));
>   }
> }
> 
> int rlxd_size(void) { return (105); }
> 
> void rlxd_get(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init[tid] == 0)
>     local_error(3);
> 
>   state[0] = rlxd_size();
> 
>   for (k = 0; k < 96; k++)
>     state[k + 1] = x[tid].num[k];
> 
>   state[97] = carry[tid].c1;
>   state[98] = carry[tid].c2;
>   state[99] = carry[tid].c3;
>   state[100] = carry[tid].c4;
> 
>   state[101] = pr[tid];
>   state[102] = ir[tid];
>   state[103] = jr[tid];
>   state[104] = is[tid];
> }
> 
> void rlxd_reset(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
>   if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24) ||
>       (DBL_MANT_DIG < 48))
>     local_error(4);
> 
>   define_constants();
> 
>   if (state[0] != rlxd_size())
>     local_error(5);
> 
>   for (k = 0; k < 96; k++) {
>     if ((state[k + 1] < 0) || (state[k + 1] >= 167777216))
>       local_error(5);
> 
>     x[tid].num[k] = state[k + 1];
>   }
> 
>   if (((state[97] != 0) && (state[97] != 1)) ||
>       ((state[98] != 0) && (state[98] != 1)) ||
>       ((state[99] != 0) && (state[99] != 1)) ||
>       ((state[100] != 0) && (state[100] != 1)))
>     local_error(5);
> 
>   carry[tid].c1 = state[97];
>   carry[tid].c2 = state[98];
>   carry[tid].c3 = state[99];
>   carry[tid].c4 = state[100];
> 
>   pr[tid] = state[101];
>   ir[tid] = state[102];
>   jr[tid] = state[103];
>   is[tid] = state[104];
>   is_old[tid] = 8 * ir[tid];
>   prm[tid] = pr[tid] % 12;
>   init[tid] = 1;
> 
>   if (((pr[tid] != 202) && (pr[tid] != 397)) || (ir[tid] < 0) ||
>       (ir[tid] > 11) || (jr[tid] < 0) || (jr[tid] > 11) ||
>       (jr[tid] != ((ir[tid] + 7) % 12)) || (is[tid] < 0) || (is[tid] > 91))
>     local_error(5);
> }
> #else
374,404d652
< static void error(int no) {
<   switch (no) {
<   case 0:
<     printf("Error in rlxd_init\n");
<     printf("Arithmetic on this machine is not suitable for ranlxd\n");
<     break;
<   case 1:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of luxury level (should be 1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxd_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxd_get\n");
<     printf("Undefined state (ranlxd is not initialized)\n");
<     break;
<   case 4:
<     printf("Error in rlxd_reset\n");
<     printf("Arithmetic on this machine is not suitable for ranlxd\n");
<     break;
<   case 5:
<     printf("Error in rlxd_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
454c702
<     error(0);
---
>     local_error(0);
463c711
<     error(1);
---
>     local_error(1);
465c713
<   i = seed;
---
>   i = seed + MPI_PID;
473c721
<     error(2);
---
>     local_error(2);
515c763
<     rlxd_init(1, 1);
---
>     local_error(6);
518a767
> 
520a770
> 
531c781
<     error(3);
---
>     local_error(3);
554c804
<     error(4);
---
>     local_error(4);
559c809
<     error(5);
---
>     local_error(5);
563c813
<       error(5);
---
>       local_error(5);
572c822
<     error(5);
---
>     local_error(5);
589c839
<     error(5);
---
>     local_error(5);
590a841
> #endif
** LibHR/Random/ranlxs.c
43a44
> #include "global.h"
50a52,77
> static void local_error(int no) {
>   switch (no) {
>   case 1:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of luxury level (should be 1 or 2)\n");
>     break;
>   case 2:
>     printf("Error in subroutine rlxd_init\n");
>     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
>     break;
>   case 3:
>     printf("Error in rlxd_get\n");
>     printf("Undefined state (ranlxd is not initialized\n");
>     break;
>   case 5:
>     printf("Error in rlxd_reset\n");
>     printf("Unexpected input data\n");
>     break;
>   case 6:
>     printf("Unitialized random seed\n");
>     break;
>   }
>   printf("Program aborted\n");
>   exit(0);
> }
> 
95,117d121
< static void error(int no) {
<   switch (no) {
<   case 1:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of luxury level (should be 0,1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxs_get\n");
<     printf("Undefined state (ranlxs is not initialized\n");
<     break;
<   case 5:
<     printf("Error in rlxs_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
190c194
<     error(1);
---
>     local_error(1);
192c196
<   i = seed;
---
>   i = seed + MPI_PID;
200c204
<     error(2);
---
>     local_error(2);
242,243c246
<     rlxs_init(0, 1);
< 
---
>     local_error(6);
259c262
<     error(3);
---
>     local_error(3);
284c287
<     error(5);
---
>     local_error(5);
288c291
<       error(5);
---
>       local_error(5);
297c300
<     error(5);
---
>     local_error(5);
314c317
<     error(5);
---
>     local_error(5);
317a321,588
> #ifdef _OPENMP
> #include "hr_omp.h"
> 
> #define BASE 0x1000000
> #define MASK 0xffffff
> typedef struct {
>   int c1, c2, c3, c4;
> } vec_t;
> 
> typedef struct {
>   vec_t c1, c2;
> } dble_vec_t;
> 
> typedef union {
>   dble_vec_t vec[12];
>   int num[96];
> } x_struct;
> 
> static int *init = NULL, *pr, *prm, *ir, *jr, *is, *is_old, *next;
> static float *one_bit;
> static vec_t *carry;
> static x_struct *x;
> 
> #define STEP(pi, pj, ltid)                                                     \
>   d = (*pj).c1.c1 - (*pi).c1.c1 - carry[ltid].c1;                              \
>   (*pi).c2.c1 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c1 = d & MASK;                                                      \
>   d = (*pj).c1.c2 - (*pi).c1.c2 - carry[ltid].c2;                              \
>   (*pi).c2.c2 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c2 = d & MASK;                                                      \
>   d = (*pj).c1.c3 - (*pi).c1.c3 - carry[ltid].c3;                              \
>   (*pi).c2.c3 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c3 = d & MASK;                                                      \
>   d = (*pj).c1.c4 - (*pi).c1.c4 - carry[ltid].c4;                              \
>   (*pi).c2.c4 += (d < 0);                                                      \
>   d += BASE;                                                                   \
>   (*pi).c1.c4 = d & MASK;                                                      \
>   d = (*pj).c2.c1 - (*pi).c2.c1;                                               \
>   carry[ltid].c1 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c1 = d & MASK;                                                      \
>   d = (*pj).c2.c2 - (*pi).c2.c2;                                               \
>   carry[ltid].c2 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c2 = d & MASK;                                                      \
>   d = (*pj).c2.c3 - (*pi).c2.c3;                                               \
>   carry[ltid].c3 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c3 = d & MASK;                                                      \
>   d = (*pj).c2.c4 - (*pi).c2.c4;                                               \
>   carry[ltid].c4 = (d < 0);                                                    \
>   d += BASE;                                                                   \
>   (*pi).c2.c4 = d & MASK
> 
> static void update(void) {
>   int k, kmax, d;
>   dble_vec_t *pmin, *pmax, *pi, *pj;
> 
>   int tid = omp_get_thread_num();
> 
>   kmax = pr[tid];
>   pmin = &(x[tid].vec[0]);
>   pmax = pmin + 12;
>   pi = &(x[tid].vec[ir[tid]]);
>   pj = &(x[tid].vec[jr[tid]]);
> 
>   for (k = 0; k < kmax; k++) {
>     STEP(pi, pj, tid);
> 
>     pi += 1;
>     pj += 1;
>     if (pi == pmax)
>       pi = pmin;
>     if (pj == pmax)
>       pj = pmin;
>   }
> 
>   ir[tid] += prm[tid];
>   jr[tid] += prm[tid];
>   if (ir[tid] >= 12)
>     ir[tid] -= 12;
>   if (jr[tid] >= 12)
>     jr[tid] -= 12;
>   is[tid] = 8 * ir[tid];
>   is_old[tid] = is[tid];
> }
> 
> static void define_constants(void) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   one_bit[tid] = (float)(ldexp(1.0, -24));
> 
>   for (k = 0; k < 96; k++) {
>     next[k + tid * 96] = (k + 1) % 96;
>   }
> }
> 
> void rlxs_init(int level, int seed) {
>   _OMP_PRAGMA(_omp_parallel) {
>     int tid = omp_get_thread_num();
>     int nt = omp_get_num_threads();
>     _OMP_PRAGMA(single) {
>       init = malloc(nt * sizeof(int) * 103);
>       pr = init + nt;
>       prm = pr + nt;
>       ir = prm + nt;
>       jr = ir + nt;
>       is = jr + nt;
>       is_old = is + nt;
>       next = is_old + nt;
> 
>       one_bit = malloc(nt * sizeof(float));
>       carry = malloc(nt * sizeof(vec_t));
>       x = malloc(nt * sizeof(x_struct));
>     }
> 
>     int i, k, l;
>     int ibit, jbit, xbit[31];
>     int ix, iy;
> 
>     if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24))
>       local_error(0);
> 
>     define_constants();
> 
>     if (level == 0)
>       pr[tid] = 109;
>     else if (level == 1)
>       pr[tid] = 202;
>     else if (level == 2)
>       pr[tid] = 397;
>     else
>       local_error(1);
> 
>     i = seed + tid + nt * MPI_PID;
> 
>     for (k = 0; k < 31; k++) {
>       xbit[k] = i % 2;
>       i /= 2;
>     }
> 
>     if ((seed <= 0) || (i != 0))
>       local_error(2);
> 
>     ibit = 0;
>     jbit = 18;
> 
>     for (i = 0; i < 4; i++) {
>       for (k = 0; k < 24; k++) {
>         ix = 0;
> 
>         for (l = 0; l < 24; l++) {
>           iy = xbit[ibit];
>           ix = 2 * ix + iy;
> 
>           xbit[ibit] = (xbit[ibit] + xbit[jbit]) % 2;
>           ibit = (ibit + 1) % 31;
>           jbit = (jbit + 1) % 31;
>         }
> 
>         if ((k % 4) == i)
>           ix = 16777215 - ix;
> 
>         x[tid].num[4 * k + i] = ix;
>       }
>     }
> 
>     carry[tid].c1 = 0;
>     carry[tid].c2 = 0;
>     carry[tid].c3 = 0;
>     carry[tid].c4 = 0;
> 
>     ir[tid] = 0;
>     jr[tid] = 7;
>     is[tid] = 95;
>     is_old[tid] = 0;
>     prm[tid] = pr[tid] % 12;
>     init[tid] = 1;
>   }
> }
> void ranlxs(float r[], int n) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init == NULL)
>     local_error(6);
> 
>   for (k = 0; k < n; k++) {
>     is[tid] = next[is[tid] + tid * 96];
>     if (is[tid] == is_old[tid])
>       update();
>     r[k] = one_bit[tid] * (float)(x[tid].num[is[tid]]);
>   }
> }
> 
> int rlxs_size(void) { return (105); }
> 
> void rlxs_get(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if (init[tid] == 0)
>     local_error(3);
> 
>   state[0] = rlxs_size();
> 
>   for (k = 0; k < 96; k++)
>     state[k + 1] = x[tid].num[k];
> 
>   state[97] = carry[tid].c1;
>   state[98] = carry[tid].c2;
>   state[99] = carry[tid].c3;
>   state[100] = carry[tid].c4;
> 
>   state[101] = pr[tid];
>   state[102] = ir[tid];
>   state[103] = jr[tid];
>   state[104] = is[tid];
> }
> 
> void rlxs_reset(int state[]) {
>   int k;
>   int tid = omp_get_thread_num();
> 
>   if ((INT_MAX < 2147483647) || (FLT_RADIX != 2) || (FLT_MANT_DIG < 24))
>     local_error(4);
> 
>   define_constants();
> 
>   if (state[0] != rlxs_size())
>     local_error(5);
> 
>   for (k = 0; k < 96; k++) {
>     if ((state[k + 1] < 0) || (state[k + 1] >= 167777216))
>       local_error(5);
> 
>     x[tid].num[k] = state[k + 1];
>   }
> 
>   if (((state[97] != 0) && (state[97] != 1)) ||
>       ((state[98] != 0) && (state[98] != 1)) ||
>       ((state[99] != 0) && (state[99] != 1)) ||
>       ((state[100] != 0) && (state[100] != 1)))
>     local_error(5);
> 
>   carry[tid].c1 = state[97];
>   carry[tid].c2 = state[98];
>   carry[tid].c3 = state[99];
>   carry[tid].c4 = state[100];
> 
>   pr[tid] = state[101];
>   ir[tid] = state[102];
>   jr[tid] = state[103];
>   is[tid] = state[104];
>   is_old[tid] = 8 * ir[tid];
>   prm[tid] = pr[tid] % 12;
>   init[tid] = 1;
> 
>   if (((pr[tid] != 109) && (pr[tid] != 202) && (pr[tid] != 397)) ||
>       (ir[tid] < 0) || (ir[tid] > 11) || (jr[tid] < 0) || (jr[tid] > 11) ||
>       (jr[tid] != ((ir[tid] + 7) % 12)) || (is[tid] < 0) || (is[tid] > 95))
>     local_error(5);
> }
> #else
373,403d643
< static void error(int no) {
<   switch (no) {
<   case 0:
<     printf("Error in rlxs_init\n");
<     printf("Arithmetic on this machine is not suitable for ranlxs\n");
<     break;
<   case 1:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of luxury level (should be 0,1 or 2)\n");
<     break;
<   case 2:
<     printf("Error in subroutine rlxs_init\n");
<     printf("Bad choice of seed (should be between 1 and 2^31-1)\n");
<     break;
<   case 3:
<     printf("Error in rlxs_get\n");
<     printf("Undefined state (ranlxs is not initialized)\n");
<     break;
<   case 4:
<     printf("Error in rlxs_reset\n");
<     printf("Arithmetic on this machine is not suitable for ranlxs\n");
<     break;
<   case 5:
<     printf("Error in rlxs_reset\n");
<     printf("Unexpected input data\n");
<     break;
<   }
<   printf("Program aborted\n");
<   exit(0);
< }
< 
449c689
<     error(0);
---
>     local_error(0);
460c700
<     error(1);
---
>     local_error(1);
462c702
<   i = seed;
---
>   i = seed + MPI_PID;
470c710
<     error(2);
---
>     local_error(2);
512c752
<     rlxs_init(0, 1);
---
>     local_error(6);
528c768
<     error(3);
---
>     local_error(3);
550c790
<     error(4);
---
>     local_error(4);
555c795
<     error(5);
---
>     local_error(5);
559c799
<       error(5);
---
>       local_error(5);
568c808
<     error(5);
---
>     local_error(5);
585c825
<     error(5);
---
>     local_error(5);
587c827
< 
---
> #endif
** LibHR/Update/D_ff.c
49,53c49,53
< extern int init_dirac;
< extern spinor_field *gtmp;
< extern spinor_field *etmp;
< extern spinor_field *otmp;
< extern spinor_field *otmp2;
---
> static int init_dirac = 1;
> static spinor_field *gtmp;
> static spinor_field *etmp;
> static spinor_field *otmp;
> static spinor_field *otmp2;
55c55,83
< void init_Dirac();
---
> static void free_mem() {
>   if (gtmp != NULL) {
>     free_spinor_field_f(gtmp);
>     gtmp = NULL;
>   }
>   if (etmp != NULL) {
>     free_spinor_field_f(etmp);
>     etmp = NULL;
>   }
>   if (otmp != NULL) {
>     free_spinor_field_f(otmp);
>     otmp = NULL;
>   }
>   if (otmp2 != NULL) {
>     free_spinor_field_f(otmp2);
>     otmp2 = NULL;
>   }
>   init_dirac = 1;
> }
> static void init_Dirac() {
>   if (init_dirac) {
>     gtmp = alloc_spinor_field_f(1, &glattice);
>     etmp = alloc_spinor_field_f(1, &glat_even);
>     otmp = alloc_spinor_field_f(1, &glat_odd);
>     otmp2 = alloc_spinor_field_f(1, &glat_odd);
>     atexit(&free_mem);
>     init_dirac = 0;
>   }
> }
** LibHR/Update/Dphi.c
39,43c39,43
< int init_dirac = 1;
< spinor_field *gtmp = NULL;
< spinor_field *etmp = NULL;
< spinor_field *otmp = NULL;
< spinor_field *otmp2 = NULL;
---
> static int init_dirac = 1;
> static spinor_field *gtmp = NULL;
> static spinor_field *etmp = NULL;
> static spinor_field *otmp = NULL;
> static spinor_field *otmp2 = NULL;
48c48
<     etmp = NULL;
---
>     gtmp = NULL;
65c65
< void init_Dirac() {
---
> static void init_Dirac() {
357a358,698
> void Dphi_fused_(spinor_field *out, spinor_field *in) {
> #ifdef CHECK_SPINOR_MATCHING
>   error((in == NULL) || (out == NULL), 1, "Dphi_ [Dphi.c]",
>         "Attempt to access unallocated memory space");
>   error(in == out, 1, "Dphi_ [Dphi.c]",
>         "Input and output fields must be different");
>   error(out->type == &glat_even && in->type == &glat_even, 1, "Dphi_ [Dphi.c]",
>         "Spinors don't match! (1)");
>   error(out->type == &glat_odd && in->type == &glat_odd, 1, "Dphi_ [Dphi.c]",
>         "Spinors don't match! (2)");
> #endif
> 
>   //++MVMcounter; /* count matrix calls */
>   // if (out->type == &glattice)
>   //  ++MVMcounter;
>   //
>   /************************ loop over all lattice sites
>    * *************************/
>   /* start communication of input spinor field */
>   _OMP_PRAGMA(master) { start_sf_sendrecv(in); }
>   _OMP_BARRIER
> 
>   int ix;
>   int iy;
>   suNf *up, *um;
>   suNf_vector psi, chi, psi2, chi2;
>   suNf_spinor *r, *sp, *sm;
> #if defined(BC_T_THETA) || defined(BC_X_THETA) || defined(BC_Y_THETA) ||       \
>     defined(BC_Z_THETA)
>   suNf_vector vtmp;
> #endif
> 
>   _OMP_PRAGMA(_omp_for nowait)
>   for (int _fuse_master_for_ip_ix = 0;
>        _fuse_master_for_ip_ix < (out->type)->fuse_inner_counter;
>        _fuse_master_for_ip_ix++) {
> 
>     ix = _FUSE_IDX(out->type, ix);
> 
>     r = _FIELD_AT(out, ix);
> 
>     /******************************* direction +0
>      * *********************************/
> 
>     iy = iup(ix, 0);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 0);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_add_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_T_multiply(chi, (*up), psi);
>     _suNf_theta_T_multiply(chi2, (*up), psi2);
> 
>     (*r).c[0] = chi;
>     (*r).c[2] = chi;
>     (*r).c[1] = chi2;
>     (*r).c[3] = chi2;
> 
>     /******************************* direction -0
>      * *********************************/
> 
>     iy = idn(ix, 0);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 0);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_sub_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_T_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_T_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction +1
>      * *********************************/
> 
>     iy = iup(ix, 1);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 1);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_i_add_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_X_multiply(chi, (*up), psi);
>     _suNf_theta_X_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -1
>      * *********************************/
> 
>     iy = idn(ix, 1);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 1);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_i_sub_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_X_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_X_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +2
>      * *********************************/
> 
>     iy = iup(ix, 2);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 2);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_sub_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_Y_multiply(chi, (*up), psi);
>     _suNf_theta_Y_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -2
>      * *********************************/
> 
>     iy = idn(ix, 2);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 2);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_add_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_Y_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Y_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +3
>      * *********************************/
> 
>     iy = iup(ix, 3);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 3);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_i_sub_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_Z_multiply(chi, (*up), psi);
>     _suNf_theta_Z_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction -3
>      * *********************************/
> 
>     iy = idn(ix, 3);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 3);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_i_add_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_Z_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Z_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************** end of loop
>      * *********************************/
> 
>     _spinor_mul_f(*r, -0.5, *r);
> 
>   } /* FUSE FOR */
> #ifdef WITH_MPI
> 
>   _OMP_PRAGMA(master) { complete_sf_sendrecv(in); }
>   _OMP_PRAGMA(barrier)
> #endif
> 
>   _OMP_PRAGMA(_omp_for nowait)
>   for (int _fuse_master_for_ip_ix = (out->type)->fuse_inner_counter;
>        _fuse_master_for_ip_ix < (out->type)->fuse_gauge_size;
>        _fuse_master_for_ip_ix++) {
>     ix = _FUSE_IDX(out->type, ix);
> 
>     r = _FIELD_AT(out, ix);
> 
>     /******************************* direction +0
>      * *********************************/
> 
>     iy = iup(ix, 0);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 0);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_add_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_T_multiply(chi, (*up), psi);
>     _suNf_theta_T_multiply(chi2, (*up), psi2);
> 
>     (*r).c[0] = chi;
>     (*r).c[2] = chi;
>     (*r).c[1] = chi2;
>     (*r).c[3] = chi2;
> 
>     /******************************* direction -0
>      * *********************************/
> 
>     iy = idn(ix, 0);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 0);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_sub_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_T_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_T_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction +1
>      * *********************************/
> 
>     iy = iup(ix, 1);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 1);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_i_add_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_X_multiply(chi, (*up), psi);
>     _suNf_theta_X_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -1
>      * *********************************/
> 
>     iy = idn(ix, 1);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 1);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_i_sub_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_X_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_X_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +2
>      * *********************************/
> 
>     iy = iup(ix, 2);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 2);
> 
>     _vector_add_f(psi, (*sp).c[0], (*sp).c[3]);
>     _vector_sub_f(psi2, (*sp).c[1], (*sp).c[2]);
>     _suNf_theta_Y_multiply(chi, (*up), psi);
>     _suNf_theta_Y_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_add_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_sub_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction -2
>      * *********************************/
> 
>     iy = idn(ix, 2);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 2);
> 
>     _vector_sub_f(psi, (*sm).c[0], (*sm).c[3]);
>     _vector_add_f(psi2, (*sm).c[1], (*sm).c[2]);
>     _suNf_theta_Y_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Y_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_sub_assign_f((*r).c[3], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_add_assign_f((*r).c[2], chi2);
> 
>     /******************************* direction +3
>      * *********************************/
> 
>     iy = iup(ix, 3);
>     sp = _FIELD_AT(in, iy);
>     up = pu_gauge_f(ix, 3);
> 
>     _vector_i_add_f(psi, (*sp).c[0], (*sp).c[2]);
>     _vector_i_sub_f(psi2, (*sp).c[1], (*sp).c[3]);
>     _suNf_theta_Z_multiply(chi, (*up), psi);
>     _suNf_theta_Z_multiply(chi2, (*up), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_sub_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_add_assign_f((*r).c[3], chi2);
> 
>     /******************************* direction -3
>      * *********************************/
> 
>     iy = idn(ix, 3);
>     sm = _FIELD_AT(in, iy);
>     um = pu_gauge_f(iy, 3);
> 
>     _vector_i_sub_f(psi, (*sm).c[0], (*sm).c[2]);
>     _vector_i_add_f(psi2, (*sm).c[1], (*sm).c[3]);
>     _suNf_theta_Z_inverse_multiply(chi, (*um), psi);
>     _suNf_theta_Z_inverse_multiply(chi2, (*um), psi2);
> 
>     _vector_add_assign_f((*r).c[0], chi);
>     _vector_i_add_assign_f((*r).c[2], chi);
>     _vector_add_assign_f((*r).c[1], chi2);
>     _vector_i_sub_assign_f((*r).c[3], chi2);
> 
>     /******************************** end of loop
>      * *********************************/
> 
>     _spinor_mul_f(*r, -0.5, *r);
> 
>   } /* FUSE FOR */
> }
> 
531d871
<     init_dirac = 0;
571d910
<     init_dirac = 0;
607d945
<     init_dirac = 0;
630d967
<     init_dirac = 0;
642d978
<     init_dirac = 0;
682d1017
<     init_dirac = 0;
705d1039
<     init_dirac = 0;
910c1244
<  * Cphi = Dphi + clover                          *
---
>  * Cphi = Dphi + exp clover                      *
** LibHR/Update/Dphi_flt.c
45c45
<     etmp = NULL;
---
>     gtmp = NULL;
** LibHR/Update/force_fermion_core.c
802,805d801
<     suNg_algebra_vector f;
<     suNf_vector ptmp;
<     suNf_spinor p;
<     suNf_FMAT s1;
815a812,816
>       suNg_algebra_vector f;
>       suNf_vector ptmp;
>       suNf_spinor p;
> 
>       suNf_FMAT s1;
** LibHR/Update/random_su2.c
27,31c27,70
< static int i_vec = NVEC, i_y = NRAN, i_v = NRAN;
< static double vec1[NVEC], vec2[NVEC], vec3[NVEC];
< static double r[NRAN], u[NRAN], v[NRAN], y[NRAN];
< 
< static void update_vec(void) {
---
> static int *i_vec = NULL, *i_y, *i_v;
> static double **vec1, **vec2, **vec3;
> static double **r, **u, **v, **y;
> 
> static void init_su2_rand() {
>   int ntd = 1;
> #ifdef _OPENMP
>   ntd = omp_get_num_threads();
>   _OMP_PRAGMA(master) {
>     lprintf("init_su2_rand", 0, "Init rand for threads, performing %d init",
>             ntd);
>   }
> #endif
>   _OMP_PRAGMA(single) {
> 
>     i_vec = malloc(sizeof(int) * ntd);
>     i_y = malloc(sizeof(int) * ntd);
>     i_v = malloc(sizeof(int) * ntd);
> 
>     vec1 = malloc(sizeof(double *) * ntd);
>     vec2 = malloc(sizeof(double *) * ntd);
>     vec3 = malloc(sizeof(double *) * ntd);
>     r = malloc(sizeof(double *) * ntd);
>     u = malloc(sizeof(double *) * ntd);
>     v = malloc(sizeof(double *) * ntd);
>     y = malloc(sizeof(double *) * ntd);
> 
>     for (int i = 0; i < ntd; i++) {
>       i_vec[i] = NVEC;
>       i_y[i] = NRAN;
>       i_v[i] = NRAN;
> 
>       vec1[i] = malloc(sizeof(double) * NVEC);
>       vec2[i] = malloc(sizeof(double) * NVEC);
>       vec3[i] = malloc(sizeof(double) * NVEC);
>       r[i] = malloc(sizeof(double) * NRAN);
>       u[i] = malloc(sizeof(double) * NRAN);
>       v[i] = malloc(sizeof(double) * NRAN);
>       y[i] = malloc(sizeof(double) * NRAN);
>     }
>   }
>   _OMP_BARRIER
> }
> static void update_vec(int tid) {
32a72
> 
35c75
<   ranlxd(r, NRAN);
---
>   ranlxd(r[tid], NRAN);
38,39c78,79
<     r1 = 2.0 * r[i] - 1.0;
<     r2 = TWO_PI * r[NVEC + i] - PI;
---
>     r1 = 2.0 * r[tid][i] - 1.0;
>     r2 = TWO_PI * r[tid][NVEC + i] - PI;
42,44c82,84
<     vec1[i] = r1;
<     vec2[i] = rsq * sin(r2);
<     vec3[i] = rsq * cos(r2);
---
>     vec1[tid][i] = r1;
>     vec2[tid][i] = rsq * sin(r2);
>     vec3[tid][i] = rsq * cos(r2);
47c87
<   i_vec = 0;
---
>   i_vec[tid] = 0;
50c90
< static void update_y(void) {
---
> static void update_y(int tid) {
54,56c94,96
<   ranlxd(y, NRAN);
<   ranlxd(u, NRAN);
<   ranlxd(r, NRAN);
---
>   ranlxd(y[tid], NRAN);
>   ranlxd(u[tid], NRAN);
>   ranlxd(r[tid], NRAN);
59,62c99,102
<     r1 = -log(1.0 - y[i]);
<     r2 = PI_HALF * y[NVEC + i];
<     r3 = log(1.0 - u[i]);
<     r4 = log(1.0 - u[NVEC + i]);
---
>     r1 = -log(1.0 - y[tid][i]);
>     r2 = PI_HALF * y[tid][NVEC + i];
>     r3 = log(1.0 - u[tid][i]);
>     r4 = log(1.0 - u[tid][NVEC + i]);
68,69c108,109
<     y[i] = r1 * s - r3;
<     y[NVEC + i] = r1 * c - r4;
---
>     y[tid][i] = r1 * s - r3;
>     y[tid][NVEC + i] = r1 * c - r4;
71,74c111,114
<     r1 = r[i] * r[i];
<     r2 = r[NVEC + i] * r[NVEC + i];
<     u[i] = r1 + r1;
<     u[NVEC + i] = r2 + r2;
---
>     r1 = r[tid][i] * r[tid][i];
>     r2 = r[tid][NVEC + i] * r[tid][NVEC + i];
>     u[tid][i] = r1 + r1;
>     u[tid][NVEC + i] = r2 + r2;
77c117
<   i_y = 0;
---
>   i_y[tid] = 0;
87a128,129
>   int tid = 0;
> #ifdef _OPENMP
89,91c131,138
<   _OMP_PRAGMA(critical) {
<     if (i_vec == NVEC)
<       update_vec();
---
>   tid = omp_get_thread_num();
> #endif
>   if (i_vec == NULL) {
>     _OMP_BARRIER
>     init_su2_rand();
>   }
>   if (i_vec[tid] == NVEC)
>     update_vec(tid);
97,98c144,145
<         if (i_y == NRAN)
<           update_y();
---
>       if (i_y[tid] == NRAN)
>         update_y(tid);
100,101c147,148
<         s0p1 = 2.0 - rhoinv * y[i_y];
<         ut = u[i_y++];
---
>       s0p1 = 2.0 - rhoinv * y[tid][i_y[tid]];
>       ut = u[tid][i_y[tid]++];
111,113c158,160
<         if (i_v == NRAN) {
<           ranlxd(v, NRAN);
<           i_v = 0;
---
>       if (i_v[tid] == NRAN) {
>         ranlxd(v[tid], NRAN);
>         i_v[tid] = 0;
115,117c162,163
< 
<         s0p1 = rhoinv * log(1.0 + rt * v[i_v++]);
<         ut = v[i_v++];
---
>       s0p1 = rhoinv * log(1.0 + rt * v[tid][i_v[tid]++]);
>       ut = v[tid][i_v[tid]++];
124,126c170,172
<         if (i_v == NRAN) {
<           ranlxd(v, NRAN);
<           i_v = 0;
---
>       if (i_v[tid] == NRAN) {
>         ranlxd(v[tid], NRAN);
>         i_v[tid] = 0;
129c175
<         s0p1 = 2.0 * v[i_v++];
---
>       s0p1 = 2.0 * v[tid][i_v[tid]++];
131c177
<         ut = v[i_v++];
---
>       ut = v[tid][i_v[tid]++];
140,142c186,188
<     s1 = sq * vec1[i_vec];
<     s2 = sq * vec2[i_vec];
<     s3 = sq * vec3[i_vec];
---
>   s1 = sq * vec1[tid][i_vec[tid]];
>   s2 = sq * vec2[tid][i_vec[tid]];
>   s3 = sq * vec3[tid][i_vec[tid]];
152,153c198
<     i_vec += 1;
<   } // OMP Critical section
---
>   i_vec[tid] += 1;
** LibHR/Update/staples.c
23,25c23,25
<   static suNg staple, tr1, tr2;
<   static suNg *p1, *p2, *p3;
<   static int nu, i, ixpmu, ixpnu, ixmnu, ixpmumnu;
---
>   suNg staple, tr1, tr2;
>   suNg *p1, *p2, *p3;
>   int nu, i, ixpmu, ixpnu, ixmnu, ixpmumnu;
** LibHR/Update/updated_hb_multilevel.c
240c240,241
<                                      int *ml_up, int *ml_skip, int nblocking,
---
>                                      int *ml_up, int *ml_skip,
>                                      int nblockingstart, int nblockingend,
245a247
>   int nblocking = nblockingend - nblockingstart + 1;
269c271,272
<                                       nblocking, smear_val, lcor);
---
>                                       nblockingstart, nblockingend, smear_val,
>                                       lcor);
276c279,280
<       measure_1pt_glueballs(nblocking, smear_val, one_point_gb);
---
>       measure_1pt_glueballs(nblockingstart, nblockingend, smear_val,
>                             one_point_gb);
** LibHR/Utils/suN_exp_group.c
48a49,50
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
52a55
>   }
92a96,97
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
96a102,103
>   }
> 
141a149,150
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
145a155
>   }
197a208,209
>     _OMP_BARRIER
>     _OMP_PRAGMA(single) {
200a213
>     }
** Make/Utils/Math_glueballs/OpProjection.m
193c193
<   Module[{psx1, psy1, psz1, psx2, psy2, psz2, psxout, psyout, pszout, irnameout, irname1, irname2, stringout, string1, string2, s1, s2, string},
---
>   Module[{psx1, psy1, psz1, psx2, psy2, psz2, psxout, psyout, pszout, irnameout, irname1, irname2, stringout, string1, string2, s1, s2, string,step},
252c252
< Add2trOpCorrelators[path1_,px1_, py1_, pz1_, irrepidx1_,charge1_, path2_,px2_, py2_, pz2_, irrepidx2_, charge2_,pxout_, pyout_, pzout_, irrepidxout_, irrepevout_]:= Module[{aa,res,success=0,CG,irname1,irname2,irnameout,cg,lridx1,lridx2,lchg1,lchg2,lpath1,lpath2,lres,cg1,i,cc,lpx1,lpy1,lpz1,lpx2,lpy2,lpz2,lev1,lev2,charge=charge1*charge2,tmp,res1,res2,oo,psx1, psy1, psz1, psx2, psy2, psz2},
---
> Add2trOpCorrelators[path1_,px1_, py1_, pz1_, irrepidx1_,charge1_, path2_,px2_, py2_, pz2_, irrepidx2_, charge2_,pxout_, pyout_, pzout_, irrepidxout_, irrepevout_]:= Module[{aa,res,success=0,CG,irname1,irname2,irnameout,cg,lridx1,lridx2,lchg1,lchg2,lpath1,lpath2,lres,cg1,i,cc,lpx1,lpy1,lpz1,lpx2,lpy2,lpz2,lev1,lev2,charge=charge1*charge2,tmp,res1,res2,oo,psx1, psy1, psz1, psx2, psy2, psz2,str},
484c484
< OpSimplify[a_] := Module[{ris = a, Ptemp, tmpris, i, normalization, sqrt},
---
> OpSimplify[ain_] := Module[{ris = ain, Ptemp, tmpris, i, normalization, sqrt},
494c494
<   ris = a //. P -> Ptemp;
---
>   ris = ain //. P -> Ptemp;
507c507
< PathUniqueIdentifier[a_] := PathUniqueIdentifier[a] = Module[{ris = a,res, Ptemp, tmpris, lper,listris,r3},
---
> PathUniqueIdentifier[ain_] := PathUniqueIdentifier[ain] = Module[{ris = ain,res, Ptemp, tmpris, lper,listris,r3},
510a511
>   If[Not[SameQ[(ris //. P :> Plus),0]] ,Print["Requested PathUniqueIdentifier of a non closed Path "];Abort[]];
538c539
< PathUniqueIdentifier[a]]
---
> PathUniqueIdentifier[ain]]
541c542
< PathUniqueIndex[a_]:= PathUniqueIdentifier[a][[2]];
---
> PathUniqueIndex[ain_]:= PathUniqueIdentifier[ain][[2]];
545,546c546,547
< MyCForm[a_] := Module[{res, res1},
<    res = ToCCodeString[CExpression[a]];
---
> MyCForm[ain_] := Module[{res, res1},
>    res = ToCCodeString[CExpression[ain]];
578c579
<               OpTmp=ExpandAll[OpTmp//.Op[a__]:>rotfun[MapOptoCindex[a]]];
---
>               OpTmp=ExpandAll[OpTmp//.Op[la__]:>rotfun[MapOptoCindex[la]]];
580c581
<               RMatrixOp=ExpandAll[RMatrixOp//.Op[a__]:>unrotfun[MapOptoCindex[a]]];
---
>               RMatrixOp=ExpandAll[RMatrixOp//.Op[la__]:>unrotfun[MapOptoCindex[la]]];
672c673
<           lpath = lpath //.  a1_. a_[A__][b__] :> {A} ;
---
>           lpath = lpath //.  a1_. la_[A__][b__] :> {A} ;
1133c1134
<   sign[a_]:=Module[{res},If[a>0,res="+",res="-"];res];
---
>   sign[ain_]:=Module[{res},If[ain>0,res="+",res="-"];res];
1159c1160
< void measure_1pt_glueballs(int nblocking, double *smear_val, double complex *gb_storage);
---
> void measure_1pt_glueballs(int nblockingstart, int nblockingend, double *smear_val, double complex *gb_storage);
** Makefile
5c5
< EXCLUDEDIR := Analysis Doc Fortran HiRep.xcodeproj
---
> EXCLUDEDIR := Analysis Doc Fortran HiRep.xcodeproj Run
** ModeNumber/mk_eigvals.c
274,276c274
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** ModeNumber/mk_modenumber.c
266,268c266
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** PureGauge/input_file_ml_measure
40c40,41
< nblk = 2
---
> nblkstart = 0
> nblkend = 3
** PureGauge/suN.c
131,133d130
<   /* finalize Monte Carlo */
<   end_mc();
< 
** PureGauge/suN_multilevel.c
87,88c87,88
<         flow.pg_v->ml_niteration, flow.pg_v->ml_nskip, flow.pg_v->nblk,
<         &(flow.pg_v->APEsmear), &(flow.pg_v->corrs));
---
>         flow.pg_v->ml_niteration, flow.pg_v->ml_nskip, flow.pg_v->nblkstart,
>         flow.pg_v->nblkend, &(flow.pg_v->APEsmear), &(flow.pg_v->corrs));
143,145d142
< 
<   /* finalize Monte Carlo */
<   end_mc_ml();
** PureGauge/suN_multilevel_measure.c
61,62c61,63
<     error(sscanf(cnfg_filename, "%*[^a]an%*fn%d", &i) != 1, 1,
<           "main [suN_multilevel_measure.c]",
---
>     char *str;
>     str = strrchr(cnfg_filename, 'n');
>     error(sscanf(str, "n%d", &i) != 1, 1, "main [suN_multilevel_measure.c]",
75,76c76,77
<         flow.pg_v->ml_niteration, flow.pg_v->ml_nskip, flow.pg_v->nblk,
<         &(flow.pg_v->APEsmear), &(flow.pg_v->corrs));
---
>         flow.pg_v->ml_niteration, flow.pg_v->ml_nskip, flow.pg_v->nblkstart,
>         flow.pg_v->nblkend, &(flow.pg_v->APEsmear), &(flow.pg_v->corrs));
110,112d110
< 
<   /* finalize Monte Carlo */
<   end_mc_ml();
** PureGauge/suN_utils.c
230,237d229
< int end_mc() {
<   WF_free();
< 
<   free_BCs();
< 
<   return 0;
< }
< 
** PureGauge/suN_utils.h
132d131
< int end_mc();
** PureGauge/suN_utils_multilevel.c
288,289c288,290
<   lprintf("INIT ML", 0, "Blocking iteration on the observables=%d\n",
<           pg_var_ml.nblk);
---
>   lprintf("INIT ML", 0,
>           "Blocking iteration on the observables (start/end)=(%d/%d)\n",
>           pg_var_ml.nblkstart, pg_var_ml.nblkend);
376,377c377,379
<   lprintf("INIT ML", 0, "Blocking iteration on the observables=%d\n",
<           pg_var_ml.nblk);
---
>   lprintf("INIT ML", 0,
>           "Blocking iteration on the observables (start/end)=(%d/%d)\n",
>           pg_var_ml.nblkstart, pg_var_ml.nblkend);
424,431d425
< 
<   return 0;
< }
< 
< int end_mc_ml() {
<   WF_free();
< 
<   free_BCs();
** PureGauge/suN_utils_multilevel.h
22c22
<   int nhb, nor, ml_levels, nblk;
---
>   int nhb, nor, ml_levels, nblkstart, nblkend;
32c32
<   input_record_t read[11];
---
>   input_record_t read[12];
51,52c51,54
<       {"nnumber of spatial blocking level to generate lueballs", "nblk = %d",  \
<        INT_T, &((varname).nblk)},                                              \
---
>       {"start index of spatial blocking level to measure glueballs",           \
>        "nblkstart = %d", INT_T, &((varname).nblkstart)},                       \
>       {"end index of spatial blocking level to measure glueballs",             \
>        "nblkend = %d", INT_T, &((varname).nblkend)},                           \
172d173
< int end_mc_ml();
** Reweight/reweight.c
236c236
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/measure_formfactor.c
256c256
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/mk_mesons.c
326c326
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/mk_mesons_with_z2semwall.c
238c238
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/mk_mesons_with_z2semwall_new.c
238c238
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/random_cnfg.c
85c85
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/random_spinor.c
87c87
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** Spectrum/trunc_mesons.c
253c253
<   rlxd_init(glb_var.rlxd_level, glb_var.rlxd_seed + PID);
---
>   rlxd_init(glb_var.rlxd_level, glb_var.rlxd_seed);
** StaticPotential/tune_HYP_smearing.c
223,225c223
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/Deflate/check_deflate.c
271,282d270
<   /*read_input(rlx_var.read,input_filename);
<   lprintf("MAIN",0,"RLXD [%d,%d]\n",rlx_var.rlxd_level,rlx_var.rlxd_seed);
<   rlxd_init(rlx_var.rlxd_level,rlx_var.rlxd_seed+MPI_PID);
<   srand(rlx_var.rlxd_seed+MPI_PID);
< 
< #ifdef GAUGE_SON
<   lprintf("MAIN",0,"Gauge group: SO(%d)\n",NG);
< #else
<   lprintf("MAIN",0,"Gauge group: SU(%d)\n",NG);
< #endif
<   lprintf("MAIN",0,"Fermion representation: " REPR_NAME " [dim=%d]\n",NF);
< */
** TestProgram/DiracOperator/speed_test_diracoperator.c
27,33d26
< static double hmass = 0.1;
< static suNg_field *g;
< 
< // static void loc_D(spinor_field *out, spinor_field *in){
< //    Dphi(hmass,out,in);
< // }
< 
36,37c29,30
<   double res1, res2, res3, res_cpu, res_gpu;
<   spinor_field *s0, *s1, *s2, *s3, *tmps;
---
>   double res1, res2, res3;
>   spinor_field *s0, *s1, *s2;
40c33
<   int n_times = 5000;
---
>   int n_times = 50000;
52c45
<   s0 = alloc_spinor_field_f(4, &glattice);
---
>   s0 = alloc_spinor_field_f(3, &glattice);
55d47
<   s3 = s2 + 1;
60d51
<   lprintf("LA_TEST", 0, "un sito %lf\n", creal(s0->ptr[2].c[0].c[0]));
64,65c55
< #pragma omp parallel
<   {
---
>   _OMP_PRAGMA(_omp_parallel num_threads(1)) {
71a62
> 
100,102c91
< 
< #pragma omp parallel default(shared)
<   {
---
>   _OMP_PRAGMA(_omp_parallel) {
104c93
<       Dphi_(s1, s0);
---
>       Dphi_fused_(s1, s0);
107d95
< 
110d97
< 
112,113c99
< #pragma omp parallel default(shared)
<   {
---
>   _OMP_PRAGMA(_omp_parallel) {
115c101
<       Dphi_(s1, s0);
---
>       Dphi_fused_(s1, s0);
124,125d109
< #pragma omp parallel num_threads(1) default(shared)
<   {
130d113
< #pragma omp barrier
133d115
< #pragma omp barrier
136c118
<   }
---
> 
** TestProgram/DiracOperator/speed_test_diracoperator_flt.c
18a19
> #include "setup.h"
68,70c69
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
** TestProgram/Geometry/check_lattice.sh
50,56d49
< done
< 
< 
< #ntests=`expr ${#test[@]} / 14`
< 
< 
< for (( i=0; i<ntests; i++ )) ; do
68c61,64
< 
---
>    echo "//Logger levels (default = -1)">>test_input
>    echo "log:default = -1">>test_input
>    echo "log:inverter = -1">>test_input
>    echo "log:forcestat = 0">>test_input
75,80c71,76
< (( ${test[$((i*14+13))]} > 18 )) && continue;
< cat test_input
< 
<    mpirun -np  ${test[$((i*14+13))]} ./check_geometry_1 -i ./test_input
<    pippo=`echo $?`;
<    if [ "${pippo}" != "0" ] ; then exit ; fi
---
>    (( ${test[$((i*14+13))]} > 18 )) && ((i--)) && continue;
>    #cat test_input
>    export OMP_NUM_THREADS=1
>    rm -f out_0
>    mpirun-openmpi-gcc11 --mca shmem posix --oversubscribe -np ${test[$((i*14+13))]} ./check_geometry_1 -i ./test_input
>    if [ "$?" != "0" ] ; then exit ; fi
82c78
<    echo "Ok!"
---
>    echo $i"/$ntests : Ok!"
** TestProgram/Integrators/check_integrator_1.c
135,137d134
<   /* finalize Monte Carlo */
<   end_mc();
< 
** TestProgram/Integrators/check_integrator_1.h
84d83
< int end_mc();
** TestProgram/Integrators/check_integrator_utils_1.c
198,213d197
< /* clean up memory */
< int end_mc() {
<   free_ghmc();
<   free_BCs();
< 
<   /* free memory */
<   free_gfield(u_gauge);
< #ifdef ALLOCATE_REPR_GAUGE_FIELD
<   free_gfield_f(u_gauge_f);
< #endif
<   if (u_scalar != NULL) {
<     free_scalar_field(u_scalar);
<   }
< 
<   return 0;
< }
** TestProgram/PureGauge/check_puregauge_3.c
66,68c66
<   rlxd_init(rlx_var.rlxd_level,
<             rlx_var.rlxd_seed +
<                 MPI_PID); /* use unique MPI_PID to shift seeds */
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/Random/Makefile
** TestProgram/Random/testlx.c
15c15,18
< 
---
> #define MAIN_PROGRAM
> #include "../Include/global.h"
> #include "../Include/hr_omp.h"
> #include "../Include/logger.h"
24c27
< int main(void) {
---
> int main(int argc, char *argv[]) {
25a29,48
>   MPI_PID = 0;
>   MPI_WORLD_SIZE = 1;
> #ifdef WITH_MPI
>   int mpiret;
>   mpiret = MPI_Init(&argc, &argv);
>   if (mpiret != MPI_SUCCESS) {
>     char mesg[MPI_MAX_ERROR_STRING];
>     int mesglen;
>     MPI_Error_string(mpiret, mesg, &mesglen);
>     printf("ERROR: %s\n", mesg);
>   }
> 
>   MPI_Comm_rank(MPI_COMM_WORLD, &MPI_PID);
>   MPI_Comm_size(MPI_COMM_WORLD, &MPI_WORLD_SIZE);
> #endif
> 
>   rlxs_init(0, 32767);
>   rlxd_init(1, 32767);
>   _OMP_PRAGMA(_omp_parallel) {
>     int local_return_value = 0;
31a55,58
>     int tid = 0;
> #ifdef _OPENMP
>     tid = omp_get_thread_num();
> #endif
38,40d64
<   rlxs_init(0, 32767);
<   rlxd_init(1, 32767);
< 
202c226,227
<     if (xsn[k] != (xs[k + 60] * sbase))
---
>       if (xsn[k] != (xs[k + 60] * sbase)) {
>         if (tid == 0 && MPI_PID == 0) {
205c230,235
< 
---
>       } else {
>         if (tid != 0 || MPI_PID != 0) {
>           test1 = 1;
>         }
>       }
>     }
207c237,241
<     if (xdn[k] != (xd[k + 39] * base))
---
>       if (xdn[k] != (xd[k + 39] * base)) {
>         if (tid == 0 && MPI_PID == 0)
>           test2 = 1;
>       } else {
>         if (tid != 0 || MPI_PID != 0)
209a244
>     }
216c251
<     return_value += 1;
---
>       local_return_value += 1;
224c259
<     return_value += 1;
---
>       local_return_value += 1;
264c299
<     return_value += 1;
---
>       local_return_value += 1;
272c307
<     return_value += 1;
---
>       local_return_value += 1;
296a332,339
> 
>     _OMP_PRAGMA(atomic)
>     return_value += local_return_value;
>   }
> #ifdef WITH_MPI
>   MPI_Finalize();
> #endif
> 
** TestProgram/RotatedSF/check_rotatedsf_1.c
124c124
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_10.c
65c65
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_2.c
106c106
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_3.c
63c63
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_4.c
64c64
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_5.c
69c69
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_6.c
68c68
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_7.c
50c50
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_8.c
65c65
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/RotatedSF/check_rotatedsf_9.c
70c70
<   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed + MPI_PID);
---
>   rlxd_init(rlx_var.rlxd_level, rlx_var.rlxd_seed);
** TestProgram/Update/check_update_1.c
101,103d100
<   /* finalize Monte Carlo */
<   end_mc();
< 
** TestProgram/Update/check_update_2.c
114,121d113
<   /* finalize Monte Carlo */
<   end_mc();
< 
<   free_gfield(u_gauge);
< #ifndef REPR_FUNDAMENTAL
<   free_gfield_f(u_gauge_f);
< #endif
< 
